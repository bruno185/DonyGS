/* OLD CODE from GS3Dp.cc */


/* Archived: fitModelToView (removed from GS3Dp.cc)
 * void fitModelToView(Model3D* model, ObserverParams* params, float target_max_dim, float margin, float percentile, int center_flag)
 *
 * Archived here per request. This copy preserves the behavior that computes a centroid
 * and stores it in the model struct without modifying vertex coordinates or params->distance.
 */
void fitModelToView(Model3D* model, ObserverParams* params, float target_max_dim, float margin, float percentile, int center_flag) {
    if (model == NULL || params == NULL) return;
    VertexArrays3D* vtx = &model->vertices;
    int n = vtx->vertex_count; if (n <= 0) return;

    double cx = 0.0, cy = 0.0, cz = 0.0; int count = 0;
    for (int i = 0; i < n; ++i) {
        Fixed32 xi = model->orig_x ? model->orig_x[i] : vtx->x[i];
        Fixed32 yi = model->orig_y ? model->orig_y[i] : vtx->y[i];
        Fixed32 zi = model->orig_z ? model->orig_z[i] : vtx->z[i];
        cx += FIXED_TO_FLOAT(xi); cy += FIXED_TO_FLOAT(yi); cz += FIXED_TO_FLOAT(zi);
        count++;
    }
    if (count > 0) {
        cx /= (double)count; cy /= (double)count; cz /= (double)count;
        model->auto_center_x = FLOAT_TO_FIXED((float)cx);
        model->auto_center_y = FLOAT_TO_FIXED((float)cy);
        model->auto_center_z = FLOAT_TO_FIXED((float)cz);
        model->auto_centered = 0; // original implementation did not mark coords as modified
    }
}




/**
 * painter_newell_sanchaV2 -- Variant using optimized bubble sort
 * --------------------------------------------------------------
 * Behavior:
 *  - Semantically identical to `painter_newell_sancha()` but uses an optimized
 *    bubble-sort style outer loop (decreasing upper bound + early exit on sorted)
 *    as requested (see pseudo-code in the change request).
 *  - The pairwise comparison performed for deciding swaps is the same sequence of
 *    tests (1..7) used by the original algorithm (depth, bbox X/Y, plane tests).
 *
 * Rationale:
 *  - This variant attempts to minimize the number of pair tests by reducing the
 *    inner loop range as larger elements bubble toward the end of the array; it
 *    also exits early if no swaps occur in a pass.
 */
void painter_newell_sanchaV2(Model3D* model, int face_count) {
    if (use_float_painter) { painter_newell_sancha_float(model, face_count); return; }
    FaceArrays3D* faces = &model->faces;
    VertexArrays3D* vtx = &model->vertices;
    int i, j;
    Fixed32* face_zmean = faces->z_mean;
    if (!face_zmean) return; // safety

    // Step 1: initial ordering by z_mean (descending stable sort on visible subset)
    int visible_count = face_count;
    if (cull_back_faces) {
        visible_count = 0;
        for (i = 0; i < face_count; ++i) {
            if (faces->display_flag[i]) faces->sorted_face_indices[visible_count++] = i;
        }
        int tail = visible_count;
        for (i = 0; i < face_count; ++i) {
            if (!faces->display_flag[i]) faces->sorted_face_indices[tail++] = i;
        }
    } else {
        for (i = 0; i < face_count; ++i) faces->sorted_face_indices[i] = i;
    }
    qsort_faces_ptr_for_cmp = faces;
    qsort(faces->sorted_face_indices, visible_count, sizeof(int), cmp_faces_by_zmean);
    qsort_faces_ptr_for_cmp = NULL;

    // Prepare caches and diagnostic buffers (same strategy as V1)
    typedef struct { int face1; int face2; } OrderedPair;
    int ordered_pairs_capacity = face_count * 4;
    OrderedPair* ordered_pairs = NULL;
    if (ordered_pairs_capacity > 0) {
        ordered_pairs = (OrderedPair*)malloc(ordered_pairs_capacity * sizeof(OrderedPair));
        if (!ordered_pairs) ordered_pairs_capacity = 0;
    }
    int ordered_pairs_count = 0;

    if (inconclusive_pairs) { free(inconclusive_pairs); inconclusive_pairs = NULL; }
    inconclusive_pairs_capacity = face_count * 4;
    if (inconclusive_pairs_capacity > 0) {
        inconclusive_pairs = (InconclusivePair*)malloc(inconclusive_pairs_capacity * sizeof(InconclusivePair));
        if (!inconclusive_pairs) inconclusive_pairs_capacity = 0;
    }
    inconclusive_pairs_count = 0;

    // Optimized bubble-like passes: outer bound decreases each pass, early exit when sorted
    int swap_count = 0;
    for (int pass = visible_count - 1; pass >= 1; --pass) {
        int tableau_trie = 1; // true: no swaps so far in this pass
        for (j = 0; j <= pass - 1; ++j) {
            int f1 = faces->sorted_face_indices[j];
            int f2 = faces->sorted_face_indices[j+1];

            // Skip pairs already declared ordered
            int already_ordered = 0;
            for (int p = 0; p < ordered_pairs_count; ++p) {
                if ((ordered_pairs[p].face1 == f1 && ordered_pairs[p].face2 == f2) ||
                    (ordered_pairs[p].face1 == f2 && ordered_pairs[p].face2 == f1)) { already_ordered = 1; break; }
            }
            if (already_ordered) continue;

            // --- Test 1: Depth overlap (cheap) ---
            if (faces->z_max[f2] <= faces->z_min[f1]) continue;
            if (faces->z_max[f1] <= faces->z_min[f2]) {
                // definite swap
                int tmp = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = faces->sorted_face_indices[j+1]; faces->sorted_face_indices[j+1] = tmp;
                tableau_trie = 0; swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }

            // --- Test 2: X bbox separation ---
            int minx1 = faces->minx[f1], maxx1 = faces->maxx[f1], miny1 = faces->miny[f1], maxy1 = faces->maxy[f1];
            int minx2 = faces->minx[f2], maxx2 = faces->maxx[f2], miny2 = faces->miny[f2], maxy2 = faces->maxy[f2];
            if (maxx1 <= minx2 || maxx2 <= minx1) continue;

            // --- Test 3: Y bbox separation ---
            if (maxy1 <= miny2 || maxy2 <= miny1) continue;

            // --- Tests 4..7: plane-based robust checks (copied from painter_newell_sancha) ---
            int n1 = faces->vertex_count[f1];
            int n2 = faces->vertex_count[f2];
            int offset1 = faces->vertex_indices_ptr[f1];
            int offset2 = faces->vertex_indices_ptr[f2];
            int k;
            Fixed64 a1 = faces->plane_a[f1]; Fixed64 b1 = faces->plane_b[f1]; Fixed64 c1 = faces->plane_c[f1]; Fixed64 d1 = faces->plane_d[f1];
            Fixed64 a2 = faces->plane_a[f2]; Fixed64 b2 = faces->plane_b[f2]; Fixed64 c2 = faces->plane_c[f2]; Fixed64 d2 = faces->plane_d[f2];
            Fixed32 epsilon = FLOAT_TO_FIXED(0.01f);

            int obs_side1 = 0; int obs_side2 = 0; int side; int all_same_side; int all_opposite_side;

            // Test 4
            obs_side1 = 0; if (d1 > (Fixed64)epsilon) obs_side1 = 1; else if (d1 < -(Fixed64)epsilon) obs_side1 = -1; else goto skipT4V2;
            all_same_side = 1;
            for (k=0; k<n2; k++) {
                int v = faces->vertex_indices_buffer[offset2+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a1 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b1 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c1 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d1;
                if  (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side1 != side) { all_same_side = 0; break; }
            }
            if (all_same_side) continue;
            skipT4V2: ;

            // Test 5
            obs_side2 = 0; if (d2 > (Fixed64)epsilon) obs_side2 = 1; else if (d2 < -(Fixed64)epsilon) obs_side2 = -1; else goto skipT5V2;
            all_opposite_side = 1;
            for (k=0; k<n1; k++) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a2 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b2 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c2 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d2;
                if  (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side2 == side) { all_opposite_side = 0; break; }
            }
            if (all_opposite_side) continue;
            skipT5V2: ;

            // Test 6
            obs_side1 = 0; if (d1 > (Fixed64)epsilon) obs_side1 = 1; else if (d1 < -(Fixed64)epsilon) obs_side1 = -1; else goto skipT6V2;
            all_opposite_side = 1;
            for (k=0; k<n2; k++) {
                int v = faces->vertex_indices_buffer[offset2+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a1 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b1 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c1 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d1;
                if  (acc > (Fixed64)epsilon) side = 1; else if  (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side1 == side) { all_opposite_side = 0; break; }
            }
            if (all_opposite_side) {
                // swap
                int tmp = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = faces->sorted_face_indices[j+1]; faces->sorted_face_indices[j+1] = tmp;
                tableau_trie = 0; swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }
            skipT6V2: ;

            // Test 7
            obs_side2 = 0; if (d2 > (Fixed64)epsilon) obs_side2 = 1; else if (d2 < -(Fixed64)epsilon) obs_side2 = -1; else goto skipT7V2;
            all_same_side = 1;
            for (k=0; k<n1; k++) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a2 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b2 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c2 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d2;
                if  (acc > (Fixed64)epsilon) side = 1; else if  (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side2 != side) { all_same_side = 0; break; }
            }
            if (all_same_side) {
                int tmp = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = faces->sorted_face_indices[j+1]; faces->sorted_face_indices[j+1] = tmp;
                tableau_trie = 0; swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }
            skipT7V2: ;

            // Non-conclusive: record and avoid re-testing
            if (inconclusive_pairs != NULL && inconclusive_pairs_count < inconclusive_pairs_capacity) {
                inconclusive_pairs[inconclusive_pairs_count].face1 = f1; inconclusive_pairs[inconclusive_pairs_count].face2 = f2; inconclusive_pairs_count++;
            }
            if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }

        } // end inner for j
        if (tableau_trie) break; // early exit, already sorted
    } // end passes
    printf("inconclusive pairs: %d, total swaps: %d\n", inconclusive_pairs_count, swap_count);
    keypress();

    if (ordered_pairs) free(ordered_pairs);
}



/**
 * painter_newell_sanchaV3 -- Variant using all-pairs double loop
 * ---------------------------------------------------------------
 * Behavior:
 *  - Same semantics as `painter_newell_sancha()` but the correction phase is performed
 *    by comparing each face to *all* subsequent faces using a nested double loop
 *    (for i=0..N-2, for j=i+1..N-1). This implements a full pairwise pass instead
 *    of adjacent-only bubble swaps.
 *
 * Rationale & tradeoffs:
 *  - This approach can be more thorough (it directly compares distant elements),
 *    but it does more pair tests (O(N^2) comparisons) and may be slower on large
 *    models unless pruned by early rejection tests (depth/bbox) — the same tests
 *    1..7 are used as in V1 for conclusive decisions.
 *  - The function preserves diagnostic behavior: ordered_pairs and inconclusive_pairs
 *    are used to avoid re-testing and to record ambiguous pairs.
 */
void painter_newell_sanchaV3(Model3D* model, int face_count) {
    if (use_float_painter) { painter_newell_sancha_float(model, face_count); return; }
    FaceArrays3D* faces = &model->faces;
    VertexArrays3D* vtx = &model->vertices;
    int i, j;
    Fixed32* face_zmean = faces->z_mean;
    if (!face_zmean) return; // safety

    // Initial ordering by z_mean (same as V1/V2)
    int visible_count = face_count;
    if (cull_back_faces) {
        visible_count = 0;
        for (i = 0; i < face_count; ++i) if (faces->display_flag[i]) faces->sorted_face_indices[visible_count++] = i;
        int tail = visible_count;
        for (i = 0; i < face_count; ++i) if (!faces->display_flag[i]) faces->sorted_face_indices[tail++] = i;
    } else {
        for (i = 0; i < face_count; ++i) faces->sorted_face_indices[i] = i;
    }
    qsort_faces_ptr_for_cmp = faces;
    qsort(faces->sorted_face_indices, visible_count, sizeof(int), cmp_faces_by_zmean);
    qsort_faces_ptr_for_cmp = NULL;

    // Prepare ordered_pairs cache and inconclusive buffer (same strategy as V1)
    typedef struct { int face1; int face2; } OrderedPair;
    int ordered_pairs_capacity = face_count * 4;
    OrderedPair* ordered_pairs = NULL;
    if (ordered_pairs_capacity > 0) {
        ordered_pairs = (OrderedPair*)malloc(ordered_pairs_capacity * sizeof(OrderedPair));
        if (!ordered_pairs) ordered_pairs_capacity = 0;
    }
    int ordered_pairs_count = 0;

    if (inconclusive_pairs) { free(inconclusive_pairs); inconclusive_pairs = NULL; }
    inconclusive_pairs_capacity = face_count * 4;
    if (inconclusive_pairs_capacity > 0) {
        inconclusive_pairs = (InconclusivePair*)malloc(inconclusive_pairs_capacity * sizeof(InconclusivePair));
        if (!inconclusive_pairs) inconclusive_pairs_capacity = 0;
    }
    inconclusive_pairs_count = 0;

    int swap_count = 0;

    // All-pairs comparison: for each face i compare to all faces j > i
    for (i = 0; i < visible_count - 1; ++i) {
        for (j = i + 1; j < visible_count; ++j) {
            int f1 = faces->sorted_face_indices[i];
            int f2 = faces->sorted_face_indices[j];

            // Skip if already known
            int already_ordered = 0;
            for (int p = 0; p < ordered_pairs_count; ++p) {
                if ((ordered_pairs[p].face1 == f1 && ordered_pairs[p].face2 == f2) ||
                    (ordered_pairs[p].face1 == f2 && ordered_pairs[p].face2 == f1)) { already_ordered = 1; break; }
            }
            if (already_ordered) continue;

            // Quick rejects / accepts (Tests 1..3)
            if (faces->z_max[f2] <= faces->z_min[f1]) continue; // f1 before f2, OK
            if (faces->z_max[f1] <= faces->z_min[f2]) {
                // definitive: f2 before f1 -> swap positions
                int tmp = faces->sorted_face_indices[i]; faces->sorted_face_indices[i] = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = tmp;
                swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }
            int minx1 = faces->minx[f1], maxx1 = faces->maxx[f1], miny1 = faces->miny[f1], maxy1 = faces->maxy[f1];
            int minx2 = faces->minx[f2], maxx2 = faces->maxx[f2], miny2 = faces->miny[f2], maxy2 = faces->maxy[f2];
            if (maxx1 <= minx2 || maxx2 <= minx1) continue;
            if (maxy1 <= miny2 || maxy2 <= miny1) continue;

            // Plane-based tests (4..7) copied from V1/V2
            int n1 = faces->vertex_count[f1];
            int n2 = faces->vertex_count[f2];
            int offset1 = faces->vertex_indices_ptr[f1];
            int offset2 = faces->vertex_indices_ptr[f2];
            int k;
            Fixed64 a1 = faces->plane_a[f1]; Fixed64 b1 = faces->plane_b[f1]; Fixed64 c1 = faces->plane_c[f1]; Fixed64 d1 = faces->plane_d[f1];
            Fixed64 a2 = faces->plane_a[f2]; Fixed64 b2 = faces->plane_b[f2]; Fixed64 c2 = faces->plane_c[f2]; Fixed64 d2 = faces->plane_d[f2];
            Fixed32 epsilon = FLOAT_TO_FIXED(0.01f);

            int obs_side1 = 0; int obs_side2 = 0; int side; int all_same_side; int all_opposite_side;

            // Test 4
            obs_side1 = 0; if (d1 > (Fixed64)epsilon) obs_side1 = 1; else if (d1 < -(Fixed64)epsilon) obs_side1 = -1; else goto skipT4V3;
            all_same_side = 1;
            for (k = 0; k < n2; ++k) {
                int v = faces->vertex_indices_buffer[offset2+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a1 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b1 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c1 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d1;
                if (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side1 != side) { all_same_side = 0; break; }
            }
            if (all_same_side) continue;
            skipT4V3: ;

            // Test 5
            obs_side2 = 0; if (d2 > (Fixed64)epsilon) obs_side2 = 1; else if (d2 < -(Fixed64)epsilon) obs_side2 = -1; else goto skipT5V3;
            all_opposite_side = 1;
            for (k = 0; k < n1; ++k) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a2 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b2 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c2 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d2;
                if (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side2 == side) { all_opposite_side = 0; break; }
            }
            if (all_opposite_side) continue;
            skipT5V3: ;

            // Test 6
            obs_side1 = 0; if (d1 > (Fixed64)epsilon) obs_side1 = 1; else if (d1 < -(Fixed64)epsilon) obs_side1 = -1; else goto skipT6V3;
            all_opposite_side = 1;
            for (k = 0; k < n2; ++k) {
                int v = faces->vertex_indices_buffer[offset2+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a1 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b1 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c1 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d1;
                if (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side1 == side) { all_opposite_side = 0; break; }
            }
            if (all_opposite_side) {
                // swap
                int tmp = faces->sorted_face_indices[i]; faces->sorted_face_indices[i] = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = tmp;
                swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }
            skipT6V3: ;

            // Test 7
            obs_side2 = 0; if (d2 > (Fixed64)epsilon) obs_side2 = 1; else if (d2 < -(Fixed64)epsilon) obs_side2 = -1; else goto skipT7V3;
            all_same_side = 1;
            for (k = 0; k < n1; ++k) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a2 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b2 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c2 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d2;
                if (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side2 != side) { all_same_side = 0; break; }
            }
            if (all_same_side) {
                int tmp = faces->sorted_face_indices[i]; faces->sorted_face_indices[i] = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = tmp;
                swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }
            skipT7V3: ;

            // Non-conclusive: record and avoid re-testing
            if (inconclusive_pairs != NULL && inconclusive_pairs_count < inconclusive_pairs_capacity) { inconclusive_pairs[inconclusive_pairs_count].face1 = f1; inconclusive_pairs[inconclusive_pairs_count].face2 = f2; inconclusive_pairs_count++; }
            if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }

        }
    }

    if (ordered_pairs) free(ordered_pairs);
}


        /* Smoke-test mode: run a small non-interactive test to validate auto-fit and key behavior */
        if (argc > 1 && strcmp(argv[1], "--smoke-test") == 0) {
            printf("Running smoke test...\n");
            /* Create a minimal OBJ file */
            const char* testfile = "smoke_test.obj";
            FILE* tf = fopen(testfile, "w");
            if (tf == NULL) {
                printf("Failed to create %s\n", testfile);
                return 1;
            }
            fputs("v 0 0 0\nv 1 0 0\nv 0 1 0\nf 1 2 3\n", tf);
            fclose(tf);

            int res = loadModel3D(model, testfile);
            if (res != 0) {
                printf("loadModel3D failed (%d)\n", res);
                return 1;
            }
            printf("auto_fit_ready=%d\n", model->auto_fit_ready);
            printf("auto_suggested_distance=%.4f\n", FIXED_TO_FLOAT(model->auto_suggested_distance));
            printf("auto_suggested_proj_scale=%.2f\n", FIXED_TO_FLOAT(model->auto_suggested_proj_scale));

            /* Simulate the '+' handler */
            Fixed32 cur = s_global_proj_scale_fixed;
            Fixed32 mulp = FLOAT_TO_FIXED(1.1f);
            Fixed32 plus_scale = FIXED_MUL_64(cur, mulp);
            printf("scale_before=%.2f scale_after_plus=%.2f\n", FIXED_TO_FLOAT(cur), FIXED_TO_FLOAT(plus_scale));

            /* Simulate the '-' handler */
            Fixed32 mulm = FLOAT_TO_FIXED(0.9f);
            Fixed32 minus_scale = FIXED_MUL_64(cur, mulm);
            printf("scale_after_minus=%.2f\n", FIXED_TO_FLOAT(minus_scale));

            /* Simulate A/Z on distance */
            Fixed32 dcur = model->auto_suggested_distance;
            Fixed32 d_a = dcur - (dcur / 10); // A (decrease by 10%)
            Fixed32 d_z = dcur + (dcur / 10); // Z (increase by 10%)
            printf("distance_before=%.4f distance_A=%.4f distance_Z=%.4f\n", FIXED_TO_FLOAT(dcur), FIXED_TO_FLOAT(d_a), FIXED_TO_FLOAT(d_z));

            printf("Smoke test completed.\n");
            return 0;
        }


        
// Lightweight wireframe processing: only transform & project vertices, set face visibility
// No per-face depth calculations or sorting performed here for maximum speed in wireframe mode
segment "code11";
void processModelWireframe(Model3D* model, ObserverParams* params, const char* filename) {
    int i, j;
    Fixed32 cos_h, sin_h, cos_v, sin_v, cos_w, sin_w;
    Fixed32 x, y, z, zo, xo, yo;
    Fixed32 inv_zo, x2d_temp, y2d_temp;

    cos_h = cos_deg_int(params->angle_h);
    sin_h = sin_deg_int(params->angle_h);
    cos_v = cos_deg_int(params->angle_v);
    sin_v = sin_deg_int(params->angle_v);
    cos_w = cos_deg_int(params->angle_w);
    sin_w = sin_deg_int(params->angle_w);

    const Fixed32 cos_h_cos_v = FIXED_MUL_64(cos_h, cos_v);
    const Fixed32 sin_h_cos_v = FIXED_MUL_64(sin_h, cos_v);
    const Fixed32 cos_h_sin_v = FIXED_MUL_64(cos_h, sin_v);
    const Fixed32 sin_h_sin_v = FIXED_MUL_64(sin_h, sin_v);
    Fixed32 scale = s_global_proj_scale_fixed;
    const Fixed32 centre_x_f = INT_TO_FIXED(CENTRE_X);
    const Fixed32 centre_y_f = INT_TO_FIXED(CENTRE_Y);
    const Fixed32 distance = params->distance;

    VertexArrays3D* vtx = &model->vertices;
    Fixed32 *x_arr = vtx->x, *y_arr = vtx->y, *z_arr = vtx->z;
    Fixed32 *xo_arr = vtx->xo, *yo_arr = vtx->yo, *zo_arr = vtx->zo;
    int *x2d_arr = vtx->x2d, *y2d_arr = vtx->y2d;
    int vcount = vtx->vertex_count;

    // Local copies for speed
    FaceArrays3D* faces = &model->faces;
    int *vertex_indices_buffer = faces->vertex_indices_buffer;
    int *vertex_indices_ptr = faces->vertex_indices_ptr;
    int *face_vertex_count = faces->vertex_count;

    for (i = 0; i < vcount; i++) {
        x = x_arr[i];
        y = y_arr[i];
        z = z_arr[i];
        Fixed32 term1 = FIXED_MUL_64(x, cos_h_cos_v);
        Fixed32 term2 = FIXED_MUL_64(y, sin_h_cos_v);
        Fixed32 term3 = FIXED_MUL_64(z, sin_v);
        zo = FIXED_ADD(FIXED_SUB(FIXED_SUB(FIXED_NEG(term1), term2), term3), distance);
        if (zo > 0) {
            // compute projected xy directly into x2d/y2d and store intermediate observer coords for depth tests
            Fixed32 xo_local = FIXED_ADD(FIXED_NEG(FIXED_MUL_64(x, sin_h)), FIXED_MUL_64(y, cos_h));
            Fixed32 yo_local = FIXED_ADD(FIXED_SUB(FIXED_NEG(FIXED_MUL_64(x, cos_h_sin_v)), FIXED_MUL_64(y, sin_h_sin_v)), FIXED_MUL_64(z, cos_v));
            inv_zo = FIXED_DIV_64(scale, zo);
            Fixed32 tmp_x = FIXED_ADD(FIXED_MUL_64(xo_local, inv_zo), centre_x_f);
            Fixed32 tmp_y = FIXED_SUB(centre_y_f, FIXED_MUL_64(yo_local, inv_zo));
            // apply screen rotation and round
            x2d_arr[i] = FIXED_ROUND_TO_INT(FIXED_ADD(FIXED_SUB(FIXED_MUL_64(cos_w, FIXED_SUB(tmp_x, centre_x_f)), FIXED_MUL_64(sin_w, FIXED_SUB(centre_y_f, tmp_y))), centre_x_f));
            y2d_arr[i] = FIXED_ROUND_TO_INT(FIXED_SUB(centre_y_f, FIXED_ADD(FIXED_MUL_64(sin_w, FIXED_SUB(tmp_x, centre_x_f)), FIXED_MUL_64(cos_w, FIXED_SUB(centre_y_f, tmp_y)))));
            // Store observer-space coordinates so subsequent face tests see valid values
            zo_arr[i] = zo;
            xo_arr[i] = xo_local;
            yo_arr[i] = yo_local;
        } else {
            // negative zo (behind camera) — mark as invalid projection and store zo<=0
            zo_arr[i] = zo;
            xo_arr[i] = 0;
            yo_arr[i] = 0;
            x2d_arr[i] = -1;
            y2d_arr[i] = -1;
        }
    }

    // Set simple visibility flag per face: visible if any vertex projected on-screen (x2d != -1)
    for (i = 0; i < faces->face_count; ++i) {
        int offset = vertex_indices_ptr[i];
        int vcount_face = face_vertex_count[i];
        int *indices_base = &vertex_indices_buffer[offset];
        int visible = 0;
        for (j = 0; j < vcount_face; ++j) {
            int vi = indices_base[j] - 1;
            if (vi >= 0 && vi < vcount && x2d_arr[vi] != -1) { visible = 1; break; }
        }
        faces->display_flag[i] = visible;
        faces->sorted_face_indices[i] = i; // identity order; no sorting required
    }
}

/* ===== ARCHIVE (moved from DONYGS.cc) =====
 * Function: move_element_remove_and_insert
 * Moved: 2026-01-11
 * Reason: replaced by optimized variant `move_element_remove_and_insert_pos` and
 *         wrapper left in place for compatibility. Original implementation
 *         archived here for reference.
 */
static int move_element_remove_and_insert(int *arr, int n, int from, int insert_idx) {
    if (from < 0 || from >= n) return 0;
    if (insert_idx < 0) insert_idx = 0;
    if (insert_idx > n-1) insert_idx = n-1;
    if (from == insert_idx) return 0;
    int val = arr[from];
    if (insert_idx < from) {
        /* shift left region [insert_idx..from-1] right by 1 */
        memmove(&arr[insert_idx+1], &arr[insert_idx], (from - insert_idx) * sizeof(int));
        arr[insert_idx] = val;
    } else {
        /* insert_idx > from: shift region [from+1..insert_idx] left by 1 */
        memmove(&arr[from], &arr[from+1], (insert_idx - from) * sizeof(int));
        arr[insert_idx] = val;
    }
    return 1;
}

/* End of archive block */



/* DEBUG bloc dans ray_cast
    // ============================================
    // DEBUG COMPLET - Écriture dans cast.txt
    // ============================================

    FILE* debug_file = fopen("cast.txt", "a");  // "a" pour append (ajouter à la fin)
    if (debug_file == NULL) {
        printf("ERREUR: Impossible d'ouvrir cast.txt\n");
        return 0;
    }

    fprintf(debug_file, "\n");
    fprintf(debug_file, "================================================================\n");
    fprintf(debug_file, "                  RAY_CAST DEBUG COMPLET                        \n");
    fprintf(debug_file, "================================================================\n");

    // 1. Info sur les faces comparées
    fprintf(debug_file, "\n[1] FACES COMPAREES:\n");
    fprintf(debug_file, "    Face f1 = %d\n", f1);
    fprintf(debug_file, "    Face f2 = %d\n", f2);

    // 2. Bounding boxes et intersection
    fprintf(debug_file, "\n[2] BOUNDING BOXES 2D:\n");
    fprintf(debug_file, "    f1: [%d,%d] -> [%d,%d]\n", minx1, miny1, maxx1, maxy1);
    fprintf(debug_file, "    f2: [%d,%d] -> [%d,%d]\n", minx2, miny2, maxx2, maxy2);
    fprintf(debug_file, "    Intersection: [%d,%d] -> [%d,%d]\n", ix0, iy0, ix1, iy1);
    fprintf(debug_file, "    Centre teste: (%d, %d)\n", cx, cy);

    // 3. Direction du rayon
    fprintf(debug_file, "\n[3] RAYON 3D:\n");
    fprintf(debug_file, "    Origine: (0, 0, 0)\n");
    fprintf(debug_file, "    Direction: (%.6f, %.6f, %.6f)\n", Dx, Dy, Dz);
    float ray_length = sqrtf(Dx*Dx + Dy*Dy + Dz*Dz);
    fprintf(debug_file, "    Longueur: %.6f %s\n", ray_length, 
        (fabsf(ray_length - 1.0f) < 0.01f) ? "(normalise)" : "(NON normalise)");

    // 4. Équations des plans
    fprintf(debug_file, "\n[4] EQUATIONS DES PLANS:\n");
    fprintf(debug_file, "    f1: %.2f*x + %.2f*y + %.2f*z + %.2f = 0\n", A1, B1, C1, D1);
    fprintf(debug_file, "    f2: %.2f*x + %.2f*y + %.2f*z + %.2f = 0\n", A2, B2, C2, D2);

    // Normaliser les normales pour voir leur direction
    float len1 = sqrtf(A1*A1 + B1*B1 + C1*C1);
    float len2 = sqrtf(A2*A2 + B2*B2 + C2*C2);
    fprintf(debug_file, "    Normale f1: (%.3f, %.3f, %.3f) [longueur=%.2f]\n", 
        A1/len1, B1/len1, C1/len1, len1);
    fprintf(debug_file, "    Normale f2: (%.3f, %.3f, %.3f) [longueur=%.2f]\n", 
        A2/len2, B2/len2, C2/len2, len2);

    // 5. Produits scalaires (denominateurs)
    fprintf(debug_file, "\n[5] PRODUITS SCALAIRES (normale . rayon):\n");
    fprintf(debug_file, "    denom1 = %.6f %s\n", denom1, 
        (denom1 < 0) ? "(face frontale)" : "(face arriere)");
    fprintf(debug_file, "    denom2 = %.6f %s\n", denom2, 
        (denom2 < 0) ? "(face frontale)" : "(face arriere)");

    // 6. Distances calculées
    fprintf(debug_file, "\n[6] DISTANCES (parametre t):\n");
    fprintf(debug_file, "    tf1 = -D1/denom1 = -(%.2f)/(%.2f) = %.6f\n", D1, denom1, tf1);
    fprintf(debug_file, "    tf2 = -D2/denom2 = -(%.2f)/(%.2f) = %.6f\n", D2, denom2, tf2);
    fprintf(debug_file, "    |tf1| = %.6f\n", fabsf(tf1));
    fprintf(debug_file, "    |tf2| = %.6f\n", fabsf(tf2));
    fprintf(debug_file, "    Difference: |tf1 - tf2| = %.6f\n", fabsf(tf1 - tf2));

    // 7. Points d'intersection 3D
    fprintf(debug_file, "\n[7] POINTS D'INTERSECTION 3D:\n");
    float x1 = Dx * tf1;
    float y1 = Dy * tf1;
    float z1 = Dz * tf1;
    float x2 = Dx * tf2;
    float y2 = Dy * tf2;
    float z2 = Dz * tf2;
    fprintf(debug_file, "    f1: (%.2f, %.2f, %.2f) -> Z = %.2f\n", x1, y1, z1, z1);
    fprintf(debug_file, "    f2: (%.2f, %.2f, %.2f) -> Z = %.2f\n", x2, y2, z2, z2);

    // Vérification: le point est-il bien sur le plan ?
    float verif1 = A1*x1 + B1*y1 + C1*z1 + D1;
    float verif2 = A2*x2 + B2*y2 + C2*z2 + D2;
    fprintf(debug_file, "    Verification f1 (devrait etre 0): %.6f %s\n", verif1,
        (fabsf(verif1) < 1.0f) ? "OK" : "ERREUR");
    fprintf(debug_file, "    Verification f2 (devrait etre 0): %.6f %s\n", verif2,
        (fabsf(verif2) < 1.0f) ? "OK" : "ERREUR");

    // 8. Z des sommets réels des faces
    fprintf(debug_file, "\n[8] Z DES SOMMETS (coordonnees 3D transformees):\n");

    // Face f1
    int off1 = faces->vertex_indices_ptr[f1];
    int n1 = faces->vertex_count[f1];
    float z_min1 = 999999.0f, z_max1 = -999999.0f, z_sum1 = 0.0f;
    fprintf(debug_file, "    f1 sommets (%d): ", n1);
    for (int k = 0; k < n1; ++k) {
        int vi = faces->vertex_indices_buffer[off1 + k] - 1;
        if (vi >= 0 && vi < vtx->vertex_count) {
            // Use observer-space Z (vtx->zo) and convert from fixed to float for human-readable debug
            float z = FIXED_TO_FLOAT(vtx->zo[vi]);
            fprintf(debug_file, "%.3f ", z);
            if (z < z_min1) z_min1 = z;
            if (z > z_max1) z_max1 = z;
            z_sum1 += z;
        }
    }
    float z_avg1 = z_sum1 / (float)n1;
    fprintf(debug_file, "\n    f1: Z_min=%.2f, Z_max=%.2f, Z_avg=%.2f\n", z_min1, z_max1, z_avg1);

    // Face f2
    int off2 = faces->vertex_indices_ptr[f2];
    int n2 = faces->vertex_count[f2];
    float z_min2 = 999999.0f, z_max2 = -999999.0f, z_sum2 = 0.0f;
    fprintf(debug_file, "    f2 sommets (%d): ", n2);
    for (int k = 0; k < n2; ++k) {
        int vi = faces->vertex_indices_buffer[off2 + k] - 1;
        if (vi >= 0 && vi < vtx->vertex_count) {
            // Use observer-space Z (vtx->zo) and convert from fixed to float for human-readable debug
            float z = FIXED_TO_FLOAT(vtx->zo[vi]);
            fprintf(debug_file, "%.3f ", z);
            if (z < z_min2) z_min2 = z;
            if (z > z_max2) z_max2 = z;
            z_sum2 += z;
        }
    }
    float z_avg2 = z_sum2 / (float)n2;
    fprintf(debug_file, "\n    f2: Z_min=%.2f, Z_max=%.2f, Z_avg=%.2f\n", z_min2, z_max2, z_avg2);

    // 9. Comparaison des Z
    fprintf(debug_file, "\n[9] ANALYSE DES Z:\n");
    fprintf(debug_file, "    Comparaison des Z moyens: ");
    if (z_avg1 < z_avg2) {
        fprintf(debug_file, "f1 plus proche (%.2f < %.2f)\n", z_avg1, z_avg2);
    } else {
        fprintf(debug_file, "f2 plus proche (%.2f < %.2f)\n", z_avg2, z_avg1);
    }

    fprintf(debug_file, "    Comparaison des Z d'intersection: ");
    if (z1 < z2) {
        fprintf(debug_file, "f1 plus proche (%.2f < %.2f)\n", z1, z2);
    } else {
        fprintf(debug_file, "f2 plus proche (%.2f < %.2f)\n", z2, z1);
    }

    fprintf(debug_file, "    Comparaison des tf: ");
    if (tf1 < tf2) {
        fprintf(debug_file, "f1 plus proche (%.2f < %.2f)\n", tf1, tf2);
    } else {
        fprintf(debug_file, "f2 plus proche (%.2f < %.2f)\n", tf2, tf1);
    }

    // 10. Résultat final
    int result;
    if (tf1 > tf2) result = 1;
    else if (tf1 < tf2) result = -1;
    else result = 0;

    fprintf(debug_file, "\n[10] RESULTAT:\n");
    fprintf(debug_file, "    Code retourne: %d\n", result);
    if (result == -1) {
        fprintf(debug_file, "    -> f1 (face %d) est PLUS PROCHE que f2 (face %d)\n", f1, f2);
    } else if (result == 1) {
        fprintf(debug_file, "    -> f2 (face %d) est PLUS PROCHE que f1 (face %d)\n", f2, f1);
    } else {
        fprintf(debug_file, "    -> Faces a egale distance (ou coplanaires)\n");
    }

    fprintf(debug_file, "\n");
    fprintf(debug_file, "================================================================\n");
    fprintf(debug_file, "                      FIN DU DEBUG                              \n");
    fprintf(debug_file, "================================================================\n");
    fprintf(debug_file, "\n\n");

    fclose(debug_file);

    // ============================================
    // FIN DU DEBUG
    // ============================================
*/



/* Compute centroid of intersection polygon between faces f1 and f2 in screen space.
 * Uses Sutherland-Hodgman polygon clipping (f1 subject, f2 clip polygon) with strict
 * inside test (points on edges are treated as outside) so touching-only cases yield
 * zero-area result. Returns 1 and sets *outx,*outy when intersection has positive
 * area; returns 0 otherwise.
 */
static int compute_intersection_centroid(Model3D* model, int f1, int f2, int* outx, int* outy, double* out_area) {
    FaceArrays3D* faces = &model->faces;
    VertexArrays3D* vtx = &model->vertices;
    int n1 = faces->vertex_count[f1];
    int n2 = faces->vertex_count[f2];
    if (n1 <= 0 || n2 <= 0) { if (out_area) *out_area = 0.0; return 0; }

    /* Build subject polygon (from f1) as doubles */
    double* sx = (double*)malloc(sizeof(double) * n1);
    double* sy = (double*)malloc(sizeof(double) * n1);
    if (!sx || !sy) { if (sx) free(sx); if (sy) free(sy); if (out_area) *out_area = 0.0; return 0; }
    int off1 = faces->vertex_indices_ptr[f1];
    for (int i = 0; i < n1; ++i) {
        int vid = faces->vertex_indices_buffer[off1 + i] - 1;
        sx[i] = (double)vtx->x2d[vid];
        sy[i] = (double)vtx->y2d[vid];
    }
    int curr_n = n1;

    /* Temporary arrays for clipping --- allocate worst-case (n1 + n2) * 2 maybe */
    double* tx = (double*)malloc(sizeof(double) * (n1 + n2 + 8));
    double* ty = (double*)malloc(sizeof(double) * (n1 + n2 + 8));
    if (!tx || !ty) { free(sx); free(sy); if (tx) free(tx); if (ty) free(ty); if (out_area) *out_area = 0.0; return 0; }

    const double EPS = 1e-9;

    int off2 = faces->vertex_indices_ptr[f2];
    for (int j = 0; j < n2; ++j) {
        int c1 = faces->vertex_indices_buffer[off2 + j] - 1;
        int c2 = faces->vertex_indices_buffer[off2 + ((j + 1) % n2)] - 1;
        double cx1 = (double)vtx->x2d[c1], cy1 = (double)vtx->y2d[c1];
        double cx2 = (double)vtx->x2d[c2], cy2 = (double)vtx->y2d[c2];

        if (curr_n == 0) break;
        int out_n = 0;

        for (int i = 0; i < curr_n; ++i) {
            int ii = i;
            int jj = (i + 1) % curr_n;
            double sx1 = sx[ii], sy1 = sy[ii];
            double sx2 = sx[jj], sy2 = sy[jj];

            /* inside test: point is strictly to the left of clip edge (cx1->cx2) */
            double cross1 = (cx2 - cx1) * (sy1 - cy1) - (cy2 - cy1) * (sx1 - cx1);
            double cross2 = (cx2 - cx1) * (sy2 - cy1) - (cy2 - cy1) * (sx2 - cx1);
            int in1 = (cross1 > EPS);
            int in2 = (cross2 > EPS);

            if (in1 && in2) {
                /* both inside -> keep end */
                tx[out_n] = sx2; ty[out_n] = sy2; out_n++;
            } else if (in1 && !in2) {
                /* leaving: emit intersection */
                double denom = (sx1 - sx2) * (cy1 - cy2) - (sy1 - sy2) * (cx1 - cx2);
                if (fabs(denom) > 1e-12) {
                    double numx = (sx1*sy2 - sy1*sx2) * (cx1 - cx2) - (sx1 - sx2) * (cx1*cy2 - cy1*cx2);
                    double numy = (sx1*sy2 - sy1*sx2) * (cy1 - cy2) - (sy1 - sy2) * (cx1*cy2 - cy1*cx2);
                    double ix = numx / denom;
                    double iy = numy / denom;
                    tx[out_n] = ix; ty[out_n] = iy; out_n++;
                }
            } else if (!in1 && in2) {
                /* entering: emit intersection then end point */
                double denom = (sx1 - sx2) * (cy1 - cy2) - (sy1 - sy2) * (cx1 - cx2);
                if (fabs(denom) > 1e-12) {
                    double numx = (sx1*sy2 - sy1*sx2) * (cx1 - cx2) - (sx1 - sx2) * (cx1*cy2 - cy1*cx2);
                    double numy = (sx1*sy2 - sy1*sx2) * (cy1 - cy2) - (sy1 - sy2) * (cx1*cy2 - cy1*cx2);
                    double ix = numx / denom;
                    double iy = numy / denom;
                    tx[out_n] = ix; ty[out_n] = iy; out_n++;
                }
                tx[out_n] = sx2; ty[out_n] = sy2; out_n++;
            } else {
                /* both outside -> nothing */
            }
        }

        /* swap tx->sx */
        if (out_n == 0) { curr_n = 0; break; }
        /* ensure capacity */
        for (int k = 0; k < out_n; ++k) { sx[k] = tx[k]; sy[k] = ty[k]; }
        curr_n = out_n;
    }

    int result = 0;
    double final_area = 0.0;
    if (curr_n >= 3) {
        /* compute signed area and centroid */
        double area2 = 0.0; /* 2*area */
        double cx = 0.0, cy = 0.0;
        for (int i = 0; i < curr_n; ++i) {
            int j = (i + 1) % curr_n;
            double a = sx[i] * sy[j] - sx[j] * sy[i];
            area2 += a;
            cx += (sx[i] + sx[j]) * a;
            cy += (sy[i] + sy[j]) * a;
        }
        double area = 0.5 * area2;
        final_area = area;
        if (fabs(area) > 1e-6) {
            cx = cx / (6.0 * area);
            cy = cy / (6.0 * area);
            *outx = (int) (cx >= 0.0 ? cx + 0.5 : cx - 0.5);
            *outy = (int) (cy >= 0.0 ? cy + 0.5 : cy - 0.5);
            result = 1;
        }
    }

    if (out_area) *out_area = final_area;
    free(sx); free(sy); free(tx); free(ty);
    return result;
}

void scan_all_overlap_noninteractive(Model3D* model, ObserverParams* params, const char* filename) {
    printf("scan_all_overlap_noninteractive removed; use interactive ',' then 'a' to scan\n"); return;

    ObserverParams local_params;
    if (!params) {
        local_params.angle_h = 30; local_params.angle_v = 20; local_params.angle_w = 0;
        local_params.distance = FLOAT_TO_FIXED(30.0);
        params = &local_params;
    }
    /* Ensure projections and preprocessing are up to date */
    processModelFast(model, params, filename);

    FaceArrays3D* faces = &model->faces;
    VertexArrays3D* vtx = &model->vertices;

    /* Build CSV buffer in memory (same logic as interactive scan) */
    const char *finalname = "overlapall.csv";
    remove(finalname);
    char *buf = NULL; size_t blen = 0, bcap = 0;
    char tmp[512]; int tn = 0;
    int matches = 0; int processed = 0;

    for (int i = 0; i < faces->face_count; ++i) {
        for (int j = i + 1; j < faces->face_count; ++j) {
            int minx1 = faces->minx[i], maxx1 = faces->maxx[i], miny1 = faces->miny[i], maxy1 = faces->maxy[i];
            int minx2 = faces->minx[j], maxx2 = faces->maxx[j], miny2 = faces->miny[j], maxy2 = faces->maxy[j];
            if (maxx1 <= minx2 || maxx2 <= minx1 || maxy1 <= miny2 || maxy2 <= miny1) { processed++; continue; }
            int ov = projected_polygons_overlap(model, i, j);
            tn = snprintf(tmp, sizeof(tmp), "face1,%d,face2,%d,overlap,%s\n", i, j, ov ? "YES" : "NO");
            if (tn < 0) { if (buf) free(buf); printf("Error forming CSV\n"); return; }
            if (blen + tn + 1 > bcap) {
                size_t need = blen + tn + 1; size_t newcap = bcap ? bcap * 2 : need + 1024; while (newcap < need) newcap *= 2; char *nb = (char*)realloc(buf, newcap); if (!nb) { if (buf) free(buf); printf("Memory alloc error\n"); return; } buf = nb; bcap = newcap;
            }
            memcpy(buf + blen, tmp, tn); blen += tn; buf[blen] = '\0';

            if ((tn = snprintf(tmp, sizeof(tmp), "face_id,vertex_order,vertex_index,x2d,y2d\n")) < 0) { if (buf) free(buf); printf("Error forming CSV\n"); return; }
            if (blen + tn + 1 > bcap) { size_t need = blen + tn + 1; size_t newcap = bcap ? bcap * 2 : need + 1024; while (newcap < need) newcap *= 2; char *nb = (char*)realloc(buf, newcap); if (!nb) { if (buf) free(buf); printf("Memory alloc error\n"); return; } buf = nb; bcap = newcap; }
            memcpy(buf + blen, tmp, tn); blen += tn; buf[blen] = '\0';

            int off1 = faces->vertex_indices_ptr[i]; int n1 = faces->vertex_count[i];
            for (int vi = 0; vi < n1; ++vi) {
                int idxv = faces->vertex_indices_buffer[off1 + vi] - 1;
                if (idxv >= 0 && idxv < vtx->vertex_count) {
                    tn = snprintf(tmp, sizeof(tmp), "%d,%d,%d,%d,%d\n", i, vi, idxv, vtx->x2d[idxv], vtx->y2d[idxv]);
                    if (tn < 0) { if (buf) free(buf); printf("Error forming CSV\n"); return; }
                    if (blen + tn + 1 > bcap) { size_t need = blen + tn + 1; size_t newcap = bcap ? bcap * 2 : need + 1024; while (newcap < need) newcap *= 2; char *nb = (char*)realloc(buf, newcap); if (!nb) { if (buf) free(buf); printf("Memory alloc error\n"); return; } buf = nb; bcap = newcap; }
                    memcpy(buf + blen, tmp, tn); blen += tn; buf[blen] = '\0';
                }
            }

            int off2 = faces->vertex_indices_ptr[j]; int n2 = faces->vertex_count[j];
            for (int vi = 0; vi < n2; ++vi) {
                int idxv = faces->vertex_indices_buffer[off2 + vi] - 1;
                if (idxv >= 0 && idxv < vtx->vertex_count) {
                    tn = snprintf(tmp, sizeof(tmp), "%d,%d,%d,%d,%d\n", j, vi, idxv, vtx->x2d[idxv], vtx->y2d[idxv]);
                    if (tn < 0) { if (buf) free(buf); printf("Error forming CSV\n"); return; }
                    if (blen + tn + 1 > bcap) { size_t need = blen + tn + 1; size_t newcap = bcap ? bcap * 2 : need + 1024; while (newcap < need) newcap *= 2; char *nb = (char*)realloc(buf, newcap); if (!nb) { if (buf) free(buf); printf("Memory alloc error\n"); return; } buf = nb; bcap = newcap; }
                    memcpy(buf + blen, tmp, tn); blen += tn; buf[blen] = '\0';
                }
            }

            if ((tn = snprintf(tmp, sizeof(tmp), "\n")) < 0) { if (buf) free(buf); printf("Error forming CSV\n"); return; }
            if (blen + tn + 1 > bcap) { size_t need = blen + tn + 1; size_t newcap = bcap ? bcap * 2 : need + 1024; while (newcap < need) newcap *= 2; char *nb = (char*)realloc(buf, newcap); if (!nb) { if (buf) free(buf); printf("Memory alloc error\n"); return; } buf = nb; bcap = newcap; }
            memcpy(buf + blen, tmp, tn); blen += tn; buf[blen] = '\0';

            matches++; processed++;
        }
    }

    /* write debug CSV */
    FILE *dbf = fopen("overlapdbg.csv","w");
    if (dbf) {
        fprintf(dbf, "face1,face2,reported,sampled,clipped_area,identical\n");
        for (int ii = 0; ii < faces->face_count; ++ii) {
            for (int jj = ii + 1; jj < faces->face_count; ++jj) {
                int minx1b = faces->minx[ii], maxx1b = faces->maxx[ii], miny1b = faces->miny[ii], maxy1b = faces->maxy[ii];
                int minx2b = faces->minx[jj], maxx2b = faces->maxx[jj], miny2b = faces->miny[jj], maxy2b = faces->maxy[jj];
                if (maxx1b <= minx2b || maxx2b <= minx1b || maxy1b <= miny2b || maxy2b <= miny1b) continue;
                int ov2 = projected_polygons_overlap(model, ii, jj);
                int sampled2 = 0; int oxminb = minx1b > minx2b ? minx1b : minx2b; int oxmaxb = maxx1b < maxx2b ? maxx1b : maxx2b; int oyminb = miny1b > miny2b ? miny1b : miny2b; int oymaxb = maxy1b < maxy2b ? maxy1b : miny2b;
                if (!(oxminb > oxmaxb || oyminb > oymaxb)) {
                    int Wb = oxmaxb - oxminb; int Hb = oymaxb - oyminb;
                    for (int ssx = 0; ssx < 3 && !sampled2; ++ssx) for (int ssy = 0; ssy < 3 && !sampled2; ++ssy) {
                        int tx2 = oxminb + (((2*ssx + 1) * Wb + 3) / 6);
                        int ty2 = oyminb + (((2*ssy + 1) * Hb + 3) / 6);
                        if (point_in_poly_int(tx2, ty2, faces, vtx, ii, faces->vertex_count[ii]) && point_in_poly_int(tx2, ty2, faces, vtx, jj, faces->vertex_count[jj])) sampled2 = 1;
                    }
                }
                int icx2 = 0, icy2 = 0; double iarea2 = 0.0; compute_intersection_centroid(model, ii, jj, &icx2, &icy2, &iarea2);
                int ident2 = faces_vertices_equal(faces, vtx, ii, jj);
                fprintf(dbf, "%d,%d,%s,%d,%.6f,%d\n", ii, jj, ov2 ? "YES" : "NO", sampled2, iarea2, ident2);
            }
        }
        fclose(dbf);
    }

    /* Attempt single-shot write to final file to avoid partials on virtual disk */
    FILE *of = fopen(finalname, "w");
    if (!of) { if (buf) free(buf); printf("Error: cannot open %s for writing\n", finalname); return; }
    if (fwrite(buf ? buf : "", 1, blen, of) != blen) { printf("Write failed while saving %s\n", finalname); fclose(of); if (buf) free(buf); return; }
    fclose(of);
    if (buf) free(buf);
    printf("Saved overlapall.csv (%d pairs written, processed %d pairs)\n", matches, processed);
}




static void ensure_vertex_capacity(int vcount) {
    if (float_vcap >= vcount) return;
    int newcap = (vcount + 15) & ~15; // align
    float_xo = (float*)realloc(float_xo, sizeof(float) * newcap);
    float_yo = (float*)realloc(float_yo, sizeof(float) * newcap);
    float_zo = (float*)realloc(float_zo, sizeof(float) * newcap);
    float_px = (float*)realloc(float_px, sizeof(float) * newcap);
    float_py = (float*)realloc(float_py, sizeof(float) * newcap);
    float_px_int = (int*)realloc(float_px_int, sizeof(int) * newcap);
    float_py_int = (int*)realloc(float_py_int, sizeof(int) * newcap);
    float_vcap = newcap;
}
static void ensure_face_capacity(int face_count) {
    // allocate if not present
    if (f_z_min_buf && f_z_max_buf && f_z_mean_buf && f_minx_buf) { if (order_cap >= face_count) return; }
    int newcap = (face_count + 7) & ~7;
    int oldcap = order_cap;
    f_z_min_buf = (float*)realloc(f_z_min_buf, sizeof(float)*newcap);
    f_z_max_buf = (float*)realloc(f_z_max_buf, sizeof(float)*newcap);
    f_z_mean_buf = (float*)realloc(f_z_mean_buf, sizeof(float)*newcap);
    f_minx_buf = (int*)realloc(f_minx_buf, sizeof(int)*newcap);
    f_maxx_buf = (int*)realloc(f_maxx_buf, sizeof(int)*newcap);
    f_miny_buf = (int*)realloc(f_miny_buf, sizeof(int)*newcap);
    f_maxy_buf = (int*)realloc(f_maxy_buf, sizeof(int)*newcap);
    f_display_buf = (int*)realloc(f_display_buf, sizeof(int)*newcap);
    f_plane_a_buf = (float*)realloc(f_plane_a_buf, sizeof(float)*newcap);
    f_plane_b_buf = (float*)realloc(f_plane_b_buf, sizeof(float)*newcap);
    f_plane_c_buf = (float*)realloc(f_plane_c_buf, sizeof(float)*newcap);
    f_plane_d_buf = (float*)realloc(f_plane_d_buf, sizeof(float)*newcap);
    f_plane_conv_buf = (int*)realloc(f_plane_conv_buf, sizeof(int)*newcap);
    // initialize newly allocated region's conversion flags to 0
    if (f_plane_conv_buf && newcap > oldcap) memset(f_plane_conv_buf + oldcap, 0, sizeof(int)*(newcap - oldcap));
}

static void ensure_order_capacity(int face_count) {
    if (order_cap >= face_count) return;
    int newcap = (face_count + 7) & ~7;
    order_buf = (int*)realloc(order_buf, sizeof(int)*newcap);
    order_cap = newcap;
}

// Comparator support for qsort in painter_newell_sancha_float (float z_mean)
static float* qsort_fz_ptr_for_cmp = NULL;
static int cmp_faces_by_f_zmean(const void* pa, const void* pb) {
    int a = *(const int*)pa;
    int b = *(const int*)pb;
    float za = qsort_fz_ptr_for_cmp[a];
    float zb = qsort_fz_ptr_for_cmp[b];
    if (za > zb) return -1;   // larger z_mean first (descending)
    if (za < zb) return 1;
    if (a < b) return -1;     // tie-breaker: smaller index first
    if (a > b) return 1;
    return 0;
}

void painter_newell_sancha_float(Model3D* model, int face_count) {
    if (!model) return;
    VertexArrays3D* vtx = &model->vertices;
    FaceArrays3D* faces = &model->faces;
    int vcount = vtx->vertex_count;

    // Ensure reusable buffers are large enough and fill them
    ensure_vertex_capacity(vcount);
    ensure_face_capacity(face_count);
    ensure_order_capacity(face_count);


    typedef struct { int face1; int face2; } OrderedPair;
    int ordered_pairs_capacity = face_count * 4;
    OrderedPair* ordered_pairs = NULL;
    if (ordered_pairs_capacity > 0) {
        ordered_pairs = (OrderedPair*)malloc(ordered_pairs_capacity * sizeof(OrderedPair));
        if (!ordered_pairs) ordered_pairs_capacity = 0;
    }
    int ordered_pairs_count = 0;

    for (int i = 0; i < vcount; ++i) {
        float_xo[i] = FIXED_TO_FLOAT(vtx->xo[i]);
        float_yo[i] = FIXED_TO_FLOAT(vtx->yo[i]);
        float_zo[i] = FIXED_TO_FLOAT(vtx->zo[i]);
    }

    // Precompute projected px/py and integer screen coords per vertex (one division per vertex)
    float proj_scale = FIXED_TO_FLOAT(s_global_proj_scale_fixed);
    for (int i = 0; i < vcount; ++i) {
        float z = float_zo[i];
        float_px[i] = (z == 0.0f) ? float_xo[i] : (float_xo[i] / z);
        float_py[i] = (z == 0.0f) ? float_yo[i] : (float_yo[i] / z);
        float screenx = (0.0f - float_px[i]) * -proj_scale + (proj_scale * 0.5f);
        float screeny = (0.0f - float_py[i]) * -proj_scale + (proj_scale * 0.5f);
        float_px_int[i] = (int)(screenx + 0.5f);
        float_py_int[i] = (int)(screeny + 0.5f);
    }

    float *f_z_min = f_z_min_buf;
    float *f_z_max = f_z_max_buf;
    float *f_z_mean = f_z_mean_buf;
    int *f_minx = f_minx_buf;
    int *f_maxx = f_maxx_buf;
    int *f_miny = f_miny_buf;
    int *f_maxy = f_maxy_buf;
    int *f_display = f_display_buf;
    float *f_plane_a = f_plane_a_buf;
    float *f_plane_b = f_plane_b_buf;
    float *f_plane_c = f_plane_c_buf;
    float *f_plane_d = f_plane_d_buf;

    float proj_cx = 0.0f, proj_cy = 0.0f;
    for (int fi = 0; fi < face_count; ++fi) {
        int off = faces->vertex_indices_ptr[fi];
        int n = faces->vertex_count[fi];
        float zmin = 1e30f, zmaxf = -1e30f, sum = 0.0f;
        int minx = 999999, maxx = -999999, miny = 999999, maxy = -999999;
        int disp = 1;
        for (int k = 0; k < n; ++k) {
            int vid = faces->vertex_indices_buffer[off + k] - 1;
            if (vid < 0 || vid >= vcount) continue;
            float z = float_zo[vid]; if (z < 0.0f) disp = 0;
            if (z < zmin) zmin = z; if (z > zmaxf) zmaxf = z; sum += z;
            // use precomputed projected ints
            int sx = float_px_int[vid];
            int sy = float_py_int[vid];
            if (sx < minx) minx = sx; if (sx > maxx) maxx = sx; if (sy < miny) miny = sy; if (sy > maxy) maxy = sy;
        }
        if (!disp || n < 3) {
            f_plane_a[fi] = f_plane_b[fi] = f_plane_c[fi] = f_plane_d[fi] = 0.0f;
            f_plane_conv_buf[fi] = 1; // mark as converted (degenerate)
        }
        else {
            // Lazily convert Fixed32 plane coefficients to float only when needed.
            // Mark as not converted for now; conversion will happen in pair tests (T4/T5).
            f_plane_conv_buf[fi] = 0;
            f_plane_a[fi] = f_plane_b[fi] = f_plane_c[fi] = f_plane_d[fi] = 0.0f;
        }
        f_z_min[fi] = (n>0)?zmin:0.0f; f_z_max[fi] = (n>0)?zmaxf:0.0f; f_z_mean[fi] = (n>0)?(sum/n):0.0f;
        f_minx[fi] = (n>0)?minx:0; f_maxx[fi] = (n>0)?maxx:0; f_miny[fi] = (n>0)?miny:0; f_maxy[fi] = (n>0)?maxy:0; f_display[fi] = disp;
    }

    // initial order: reuse buffer
    int* order = order_buf;
    int visible_count = face_count;
    if (cull_back_faces) {
        visible_count = 0;
        for (int i = 0; i < face_count; ++i) {
            if (f_display[i]) order[visible_count++] = i;
        }
        // append culled faces to keep rest of array stable
        int tail = visible_count;
        for (int i = 0; i < face_count; ++i) {
            if (!f_display[i]) order[tail++] = i;
        }
    } else {
        for (int i = 0; i < face_count; ++i) order[i] = i;
    }

    // Sort faces by z_mean using qsort to match fixed-point painter (descending, tie-breaker: smaller index first)
    if (visible_count > 0) {
        qsort_fz_ptr_for_cmp = f_z_mean;
        qsort(order, visible_count, sizeof(int), cmp_faces_by_f_zmean);
        qsort_fz_ptr_for_cmp = NULL;
    }

    int swapped_local = 0;
    do {
        swapped_local = 0;
        for (int i = 0; i < visible_count - 1; ++i) {
            int f1 = order[i], f2 = order[i+1];
            /* linear check against ordered_pairs array */
            int already_ordered = 0;
            int p;
            for (p = 0; p < ordered_pairs_count; ++p) {
                if (ordered_pairs[p].face1 == f1 && ordered_pairs[p].face2 == f2) { already_ordered = 1; break; }
            }
            if (already_ordered) continue; 

            // Test 1 : Depth overlap (float)
            if (f_z_max[f2] <= f_z_min[f1]) continue;
            if (f_z_max[f1] <= f_z_min[f2]) {
                int tmp = order[i]; order[i] = order[i+1]; order[i+1] = tmp;
                swapped_local = 1;
                // record pair in ordered_pairs array (f2 before f1)
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) {
                    ordered_pairs[ordered_pairs_count].face1 = f2;
                    ordered_pairs[ordered_pairs_count].face2 = f1;
                    ordered_pairs_count++;
                }
                continue; 
            }

            // Test 2 : X overlap
            int minx1 = f_minx[f1], maxx1 = f_maxx[f1], miny1 = f_miny[f1], maxy1 = f_maxy[f1];
            int minx2 = f_minx[f2], maxx2 = f_maxx[f2], miny2 = f_miny[f2], maxy2 = f_maxy[f2];
            if (maxx1 <= minx2 || maxx2 <= minx1) continue;

            // Test 3 : Y overlap
            if (maxy1 <= miny2 || maxy2 <= miny1) continue;


            if (!projected_polygons_overlap(model, f1, f2)) continue;

            // Plane tests (4..7) using float plane coefficients
            int n1 = faces->vertex_count[f1];
            int n2 = faces->vertex_count[f2];
            int offset1 = faces->vertex_indices_ptr[f1];
            int offset2 = faces->vertex_indices_ptr[f2];
            float a1, b1, c1, d1;
            if (!f_plane_conv_buf[f1]) {
                a1 = (float)FIXED64_TO_FLOAT(faces->plane_a[f1]);
                b1 = (float)FIXED64_TO_FLOAT(faces->plane_b[f1]);
                c1 = (float)FIXED64_TO_FLOAT(faces->plane_c[f1]);
                d1 = (float)FIXED64_TO_FLOAT(faces->plane_d[f1]);
                f_plane_a[f1] = a1; f_plane_b[f1] = b1; f_plane_c[f1] = c1; f_plane_d[f1] = d1;
                f_plane_conv_buf[f1] = 1;
            } else { a1 = f_plane_a[f1]; b1 = f_plane_b[f1]; c1 = f_plane_c[f1]; d1 = f_plane_d[f1]; }

            float a2, b2, c2, d2;
            if (!f_plane_conv_buf[f2]) {
                a2 = (float)FIXED64_TO_FLOAT(faces->plane_a[f2]);
                b2 = (float)FIXED64_TO_FLOAT(faces->plane_b[f2]);
                c2 = (float)FIXED64_TO_FLOAT(faces->plane_c[f2]);
                d2 = (float)FIXED64_TO_FLOAT(faces->plane_d[f2]);
                f_plane_a[f2] = a2; f_plane_b[f2] = b2; f_plane_c[f2] = c2; f_plane_d[f2] = d2;
                f_plane_conv_buf[f2] = 1;
            } else { a2 = f_plane_a[f2]; b2 = f_plane_b[f2]; c2 = f_plane_c[f2]; d2 = f_plane_d[f2]; }

            /* Align epsilon with fixed-point painter */
            // float epsilon_f = 0.001f;
            float epsilon_f = 0.01f;

            // Test 4
            int obs_side1 = 0;
            int k;
            float test_val;
            if (d1 > epsilon_f) obs_side1 = 1; else if (d1 < -epsilon_f) obs_side1 = -1; else goto skipT4_float;
            int all_same_side = 1;
            for (k = 0; k < n2; ++k) {
                int v = faces->vertex_indices_buffer[offset2 + k] - 1;
                test_val = a1 * float_xo[v] + b1 * float_yo[v] + c1 * float_zo[v] + d1;  // plane of f1
                int side = (test_val > epsilon_f) ? 1 : ((test_val < -epsilon_f) ? -1 : 0);
                if (side != obs_side1) { all_same_side = 0; break; }
            }
            if (all_same_side) continue;
            skipT4_float: ;

            // Test 5
            int obs_side2 = 0; int all_opposite_side = 1;
            if (d2 > epsilon_f) obs_side2 = 1; else if (d2 < -epsilon_f) obs_side2 = -1; else goto skipT5_float;
            for (k = 0; k < n1; ++k) {
                int v = faces->vertex_indices_buffer[offset1 + k] - 1;
                test_val = a2 * float_xo[v] + b2 * float_yo[v] + c2 * float_zo[v] + d2; // plane of f2
                int side = (test_val > epsilon_f) ? 1 : ((test_val < -epsilon_f) ? -1 : 0);
                if (side == obs_side2) { all_opposite_side = 0; break; }
            }
            if (all_opposite_side) continue;
            
            skipT5_float: ;
        
            // Test 6 : Is f2 entirely on the opposite side of f1's plane relative to the observer?
            obs_side1 = 0;
            if (d1 > epsilon_f) obs_side1 = 1;
            else if (d1 < -epsilon_f) obs_side1 = -1;
            else goto skipT6_float;

            all_opposite_side = 1;
            for (k = 0; k < n2; ++k) {
                int v = faces->vertex_indices_buffer[offset2 + k] - 1;
                test_val = a1 * float_xo[v] + b1 * float_yo[v] + c1 * float_zo[v] + d1;
                int side = (test_val > epsilon_f) ? 1 : ((test_val < -epsilon_f) ? -1 : 0);
                if (side == 0) continue; /* ignore vertices exactly on the plane */
                if (obs_side1 == side) { 
                    all_opposite_side = 0; 
                    break; 
                }
            }
            if (all_opposite_side == 1) goto do_swap;

            skipT6_float: ;

            // Test 7 : Is f1 entirely on the same side of f2's plane as the observer?
            obs_side2 = 0;
            if (d2 > epsilon_f) obs_side2 = 1;
            else if (d2 < -epsilon_f) obs_side2 = -1;
            else goto skipT7_float;
            all_same_side = 1;
            for (k = 0; k < n1; ++k) {
                int v = faces->vertex_indices_buffer[offset1 + k] - 1;
                test_val = a2 * float_xo[v] + b2 * float_yo[v] + c2 * float_zo[v] + d2;
                int side = (test_val > epsilon_f) ? 1 : ((test_val < -epsilon_f) ? -1 : 0);
                if (side == 0) continue; /* ignore vertices exactly on the plane */
                if (obs_side2 != side) { 
                    all_same_side = 0; 
                    break; 
                }
            }
            if (all_same_side == 0) goto skipT7_float;
            else {
                goto do_swap;
            }

            // Si on arrive ici, les tests 1..5 n'ont pas conclu :
            // appliquer l'algorithme original de Newell/Newell/Sancha
            // => échanger les faces (swap) et enregistrer la paire
            do_swap:
            {
                int tmp = order[i]; order[i] = order[i+1]; order[i+1] = tmp;
                swapped_local = 1;
                // record pair in ordered_pairs array (f2 before f1)
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) {
                    ordered_pairs[ordered_pairs_count].face1 = f2;
                    ordered_pairs[ordered_pairs_count].face2 = f1;
                    ordered_pairs_count++;
                }
            }

            skipT7_float: ;

        } // end for
    } while (swapped_local);

    // write back order to faces->sorted_face_indices (visible faces first)
    int tail = 0;
    for (int i = 0; i < visible_count; ++i) faces->sorted_face_indices[tail++] = order[i];
    // append culled faces to fill rest (if culling active)
    if (cull_back_faces) {
        for (int i = 0; i < face_count; ++i) if (!f_display[i]) faces->sorted_face_indices[tail++] = i;
    } else {
        for (int i = visible_count; i < face_count; ++i) faces->sorted_face_indices[tail++] = order[i];
    }

    if (ordered_pairs) free(ordered_pairs);

    // Note: buffers are reused across invocations to avoid malloc/free overhead

}


********************* MSC *********************
/* Strict segment intersection with epsilon tolerance (in pixels)
 * --------------------------------------------------------------
 * - Uses orient_ll for orientation tests
 * - Uses integer arithmetic only
 * - Epsilon = 0.5 px implemented as a rational threshold on t and u
 */
static int segs_intersect_int(int x1,int y1,int x2,int y2,
                              int x3,int y3,int x4,int y4)
{
    Fixed64 o1 = orient_ll(x1,y1,x2,y2,x3,y3);
    Fixed64 o2 = orient_ll(x1,y1,x2,y2,x4,y4);
    Fixed64 o3 = orient_ll(x3,y3,x4,y4,x1,y1);
    Fixed64 o4 = orient_ll(x3,y3,x4,y4,x2,y2);

    /* Proper intersection only: strict opposite orientations */
    if (!(((o1 > 0 && o2 < 0) || (o1 < 0 && o2 > 0)) &&
          ((o3 > 0 && o4 < 0) || (o3 < 0 && o4 > 0))))
        return 0;

    /* At this point, segments intersect strictly in the mathematical sense.
     * Now compute t and u (parametric positions) to check proximity to endpoints.
     *
     * Intersection formula:
     *   t = orient((x3,y3)-(x1,y1), (x4,y4)-(x3,y3)) / orient((x2,y2)-(x1,y1), (x4,y4)-(x3,y3))
     *   u = orient((x3,y3)-(x1,y1), (x2,y2)-(x1,y1)) / orient((x2,y2)-(x1,y1), (x4,y4)-(x3,y3))
     *
     * We only need to compare t and u to epsilon = 0.5 px.
     * Instead of computing t as a float, we compare:
     *   t < eps  <=>  |t_num| < eps * |den|
     *   t > 1-eps <=> |den - t_num| < eps * |den|
     */

    Fixed64 rx = x2 - x1;
    Fixed64 ry = y2 - y1;
    Fixed64 sx = x4 - x3;
    Fixed64 sy = y4 - y3;

    long long den = rx * sy - ry * sx;   /* same as rxs */
    if (den == 0) return 0;              /* parallel (should not happen here) */

    long long t_num = (Fixed64)(x3 - x1) * sy - (Fixed64)(y3 - y1) * sx;
    long long u_num = (Fixed64)(x3 - x1) * ry - (Fixed64)(y3 - y1) * rx;

    /* We want to reject intersections that occur within `eps_px` pixels of any segment endpoint.
     * Accurate test (integer arithmetic):
     *   distance^2 = (t^2) * len2A  where t = t_num/den and len2A = rx^2 + ry^2
     *   require distance >= eps_px (here 0.5) -> t^2 * len2A >= eps_px^2
     * Multiply both sides by den^2 and scale by 4 to avoid fractions:
     *   4 * t_num^2 * len2A >= den^2  (since eps_px^2 = 0.25)
     * Similar checks for (1 - t) and for u on segment B.
     */
    long long len2A = rx*rx + ry*ry;
    long long len2B = sx*sx + sy*sy;

    /* Protect against degenerate zero-length segments (shouldn't happen) */
    if (len2A == 0 || len2B == 0) return 0;

    /* epsilon = 0.5 px → threshold = 0.5 * |den| */
    Fixed64 eps_num = abs_den / 2;  /* integer division = 0.5 * den */
    /* If t is too close to 0 or 1 → touching → ignore */
    if (abs_t < eps_num) return 0;
    if (abs_den - abs_t < eps_num) return 0;

    /* Same for u */
    if (abs_u < eps_num) return 0;
    if (abs_den - abs_u < eps_num) return 0;

    /* Otherwise: true strict intersection */
    return 1;
}



/* Strict segment intersection with rational epsilon.
 * 32-bit safe, no long long, no division for t/u.
 * Detects real intersections even if projected near a vertex.
 * Filters only intersections where t or u is extremely close to 0 or 1.
 */

static int segs_intersect_int(int x1,int y1,int x2,int y2,
                              int x3,int y3,int x4,int y4)
{
    
    /* 1. Strict orientation test */
    int o1 = orient_ll(x1,y1,x2,y2,x3,y3);
    int o2 = orient_ll(x1,y1,x2,y2,x4,y4);
    int o3 = orient_ll(x3,y3,x4,y4,x1,y1);
    int o4 = orient_ll(x3,y3,x4,y4,x2,y2);

    if (!(((o1 > 0 && o2 < 0) || (o1 < 0 && o2 > 0)) &&
          ((o3 > 0 && o4 < 0) || (o3 < 0 && o4 > 0))))
        return 0;

    /* 2. Compute denominator (rx × sy − ry × sx) */
    int rx = x2 - x1;
    int ry = y2 - y1;
    int sx = x4 - x3;
    int sy = y4 - y3;

    int den = rx * sy - ry * sx;
    if (den == 0) return 0;

    int abs_den = den < 0 ? -den : den;

    /* 3. Compute t_num and u_num (no division) */
    int dx = x3 - x1;
    int dy = y3 - y1;

    int t_num = dx * sy - dy * sx;
    int u_num = dx * ry - dy * rx;

    int abs_t = t_num < 0 ? -t_num : t_num;
    int abs_u = u_num < 0 ? -u_num : u_num;

    /* 4. Rational epsilon: intersection too close to endpoints?
     *
     * epsilon = 0.02 (2%) → enough to filter artefacts
     * but keeps real intersections even near vertices.
     *
     * Implemented as:
     *   abs(t) < eps * abs(den)
     *   abs(den - t) < eps * abs(den)
     *
     * Using integer math:
     *   eps_num = abs_den / 50   (≈ 0.02)
     */

    int eps = abs_den / 50;   /* rational epsilon ≈ 0.02 */

    /* If t is extremely close to 0 or 1 → touching → ignore */
    if (abs_t < eps) return 0;
    if (abs_den - abs_t < eps) return 0;

    /* Same for u */
    if (abs_u < eps) return 0;
    if (abs_den - abs_u < eps) return 0;

    /* Otherwise: real intersection */
    return 1;
}
********************* fin MSC *********************

********************* inspect_polygons_overlap avec debug *********************
void inspect_polygons_overlap(Model3D* model, ObserverParams* params, const char* filename) {
    if (!model || !params) return;
    FaceArrays3D* faces = &model->faces;
    VertexArrays3D* vtx = &model->vertices;
    int face_count = faces->face_count;
    if (face_count <= 0) { printf("No faces in model\n"); return; }

    // Inform the user what this inspector does before asking for input
    printf("Inspector: check whether two faces' 2D projections overlap (touching = NON-overlap).\n");

    // Prompt for face 1
    printf("Enter face id 1 (0..%d): ", face_count - 1);
    int f1 = -1;
    if (scanf("%d", &f1) != 1) { int ch; while ((ch = getchar()) != '\n' && ch != EOF); printf("Input cancelled\n"); return; }
    { int ch; while ((ch = getchar()) != '\n' && ch != EOF); }
    if (f1 < 0 || f1 >= face_count) { printf("Invalid face id 1\n"); return; }

    // Prompt for face 2
    printf("Enter face id 2 (0..%d): ", face_count - 1);
    int f2 = -1;
    if (scanf("%d", &f2) != 1) { int ch; while ((ch = getchar()) != '\n' && ch != EOF); printf("Input cancelled\n"); return; }
    { int ch; while ((ch = getchar()) != '\n' && ch != EOF); }
    if (f2 < 0 || f2 >= face_count) { printf("Invalid face id 2\n"); return; }

    // Report IDs and result
    int ov = projected_polygons_overlap(model, f1, f2);
    printf("Faces: %d and %d -> Projected overlap: %s\n", f1, f2, ov ? "YES" : "NO");

    /* Verbose diagnostics forced on for inspection */
    int dbg_pair_i = 1; /* forced */
    if (dbg_pair_i || !ov) {
        printf("OVERLAP_DEBUG_INSPECT: pair %d,%d -> ov=%d\n", f1, f2, ov);
        // proper segment intersection
        int segi = 0;
        for (int i = 0; i < faces->vertex_count[f1] && !segi; ++i) {
            int i2 = (i+1)%faces->vertex_count[f1];
            int a = faces->vertex_indices_buffer[faces->vertex_indices_ptr[f1] + i] - 1;
            int b = faces->vertex_indices_buffer[faces->vertex_indices_ptr[f1] + i2] - 1;
            for (int j = 0; j < faces->vertex_count[f2]; ++j) {
                int j2 = (j+1)%faces->vertex_count[f2];
                int c = faces->vertex_indices_buffer[faces->vertex_indices_ptr[f2] + j] - 1;
                int d = faces->vertex_indices_buffer[faces->vertex_indices_ptr[f2] + j2] - 1;
                if (segs_intersect_int(vtx->x2d[a], vtx->y2d[a], vtx->x2d[b], vtx->y2d[b], vtx->x2d[c], vtx->y2d[c], vtx->x2d[d], vtx->y2d[d])) { segi = 1; break; }
            }
        }
        // containment
        int cont12 = 0, cont21 = 0;
        for (int ii = 0; ii < faces->vertex_count[f1] && !cont12; ++ii) {
            int vid = faces->vertex_indices_buffer[faces->vertex_indices_ptr[f1] + ii] - 1; if (vid < 0) continue;
            if (point_in_poly_int(vtx->x2d[vid], vtx->y2d[vid], faces, vtx, f2, faces->vertex_count[f2])) cont12 = 1;
        }
        for (int ii = 0; ii < faces->vertex_count[f2] && !cont21; ++ii) {
            int vid = faces->vertex_indices_buffer[faces->vertex_indices_ptr[f2] + ii] - 1; if (vid < 0) continue;
            if (point_in_poly_int(vtx->x2d[vid], vtx->y2d[vid], faces, vtx, f1, faces->vertex_count[f1])) cont21 = 1;
        }
        // sampling (store samples for file output)
        int xs1[32], ys1[32], xs2[32], ys2[32]; int n1 = faces->vertex_count[f1], n2 = faces->vertex_count[f2];
        for (int k = 0; k < n1; ++k) { int vid = faces->vertex_indices_buffer[faces->vertex_indices_ptr[f1] + k] - 1; xs1[k] = vtx->x2d[vid]; ys1[k] = vtx->y2d[vid]; }
        for (int k = 0; k < n2; ++k) { int vid = faces->vertex_indices_buffer[faces->vertex_indices_ptr[f2] + k] - 1; xs2[k] = vtx->x2d[vid]; ys2[k] = vtx->y2d[vid]; }
        int oxmin = xs1[0], oxmax = xs1[0], oymin = ys1[0], oymax = ys1[0];
        for (int k = 1; k < n1; ++k) { if (xs1[k] < oxmin) oxmin = xs1[k]; if (xs1[k] > oxmax) oxmax = xs1[k]; if (ys1[k] < oymin) oymin = ys1[k]; if (ys1[k] > oymax) oymax = ys1[k]; }
        for (int k = 0; k < n2; ++k) { if (xs2[k] < oxmin) oxmin = xs2[k]; if (xs2[k] > oxmax) oxmax = xs2[k]; if (ys2[k] < oymin) oymin = ys2[k]; if (ys2[k] > oymax) oymax = ys2[k]; }
        int sample_ok = 0; int samp_pts[9][4]; int samp_count = 0; if (!(oxmin > oxmax || oymin > oymax)) {
            int W = oxmax - oxmin; int H = oymax - oymin;
            for (int sx = 0; sx < 3; ++sx) for (int sy = 0; sy < 3; ++sy) {
                int tx = oxmin + (((2*sx + 1) * W + 3) / 6);
                int ty = oymin + (((2*sy + 1) * H + 3) / 6);
                int in1 = point_in_poly_int(tx, ty, faces, vtx, f1, n1);
                int in2 = point_in_poly_int(tx, ty, faces, vtx, f2, n2);
                samp_pts[samp_count][0] = tx; samp_pts[samp_count][1] = ty; samp_pts[samp_count][2] = in1; samp_pts[samp_count][3] = in2; samp_count++;
                if (in1 && in2) sample_ok = 1;
                printf("  sample (%d,%d) in1=%d in2=%d\n", tx, ty, in1, in2);
            }
        }
        int icx1 = 0, icy1 = 0, icx2 = 0, icy2 = 0; double ia1=0.0, ia2=0.0;
        /* Request debug capture of clipped verts for each order so we can write them to file */
        debug_overlap_subj = f1; debug_overlap_clip = f2;
        compute_intersection_centroid_ordered(model, f1, f2, &icx1, &icy1, &ia1);
        /* capture debug buffers for order 1 */
        int clip1_vcount = debug_clip_vcount;
        int *clip1_vx = NULL; int *clip1_vy = NULL;
        long long clip1_raw_area2 = debug_clip_raw_area2; double clip1_area = debug_clip_area; int clip1_centx = debug_clip_centroid_x; int clip1_centy = debug_clip_centroid_y;
        if (clip1_vcount > 0) {
            clip1_vx = (int*)malloc(clip1_vcount * sizeof(int));
            clip1_vy = (int*)malloc(clip1_vcount * sizeof(int));
            if (clip1_vx && clip1_vy) {
                for (int ii = 0; ii < clip1_vcount; ++ii) { clip1_vx[ii] = debug_clip_vx[ii]; clip1_vy[ii] = debug_clip_vy[ii]; }
            } else {
                /* allocation failed: drop verts */
                if (clip1_vx) { free(clip1_vx); clip1_vx = NULL; }
                if (clip1_vy) { free(clip1_vy); clip1_vy = NULL; }
                clip1_vcount = 0;
            }
        }
        debug_overlap_subj = -1; debug_overlap_clip = -1;

        /* capture float fallback diagnostics for order 1 */
        double clip1_float_area = debug_clip_float_area;
        int clip1_float_overridden = debug_clip_float_overridden;
        int clip1_float_vcount = debug_clip_float_vcount;
        int *clip1_float_vx = NULL; int *clip1_float_vy = NULL;
        if (clip1_float_vcount > 0) {
            clip1_float_vx = (int*)malloc(clip1_float_vcount * sizeof(int));
            clip1_float_vy = (int*)malloc(clip1_float_vcount * sizeof(int));
            if (clip1_float_vx && clip1_float_vy) {
                for (int ii = 0; ii < clip1_float_vcount; ++ii) { clip1_float_vx[ii] = debug_clip_float_vx[ii]; clip1_float_vy[ii] = debug_clip_float_vy[ii]; }
            } else {
                if (clip1_float_vx) { free(clip1_float_vx); clip1_float_vx = NULL; }
                if (clip1_float_vy) { free(clip1_float_vy); clip1_float_vy = NULL; }
                clip1_float_vcount = 0;
            }
        }

        debug_overlap_subj = f2; debug_overlap_clip = f1;
        compute_intersection_centroid_ordered(model, f2, f1, &icx2, &icy2, &ia2);
        /* capture debug buffers for order 2 */
        int clip2_vcount = debug_clip_vcount;
        int *clip2_vx = NULL; int *clip2_vy = NULL;
        long long clip2_raw_area2 = debug_clip_raw_area2; double clip2_area = debug_clip_area; int clip2_centx = debug_clip_centroid_x; int clip2_centy = debug_clip_centroid_y;
        if (clip2_vcount > 0) {
            clip2_vx = (int*)malloc(clip2_vcount * sizeof(int));
            clip2_vy = (int*)malloc(clip2_vcount * sizeof(int));
            if (clip2_vx && clip2_vy) {
                for (int ii = 0; ii < clip2_vcount; ++ii) { clip2_vx[ii] = debug_clip_vx[ii]; clip2_vy[ii] = debug_clip_vy[ii]; }
            } else {
                /* allocation failed: drop verts */
                if (clip2_vx) { free(clip2_vx); clip2_vx = NULL; }
                if (clip2_vy) { free(clip2_vy); clip2_vy = NULL; }
                clip2_vcount = 0;
            }
        }
        debug_overlap_subj = -1; debug_overlap_clip = -1;

        /* capture float fallback diagnostics for order 2 */
        double clip2_float_area = debug_clip_float_area;
        int clip2_float_overridden = debug_clip_float_overridden;
        int clip2_float_vcount = debug_clip_float_vcount;
        int *clip2_float_vx = NULL; int *clip2_float_vy = NULL;
        if (clip2_float_vcount > 0) {
            clip2_float_vx = (int*)malloc(clip2_float_vcount * sizeof(int));
            clip2_float_vy = (int*)malloc(clip2_float_vcount * sizeof(int));
            if (clip2_float_vx && clip2_float_vy) {
                for (int ii = 0; ii < clip2_float_vcount; ++ii) { clip2_float_vx[ii] = debug_clip_float_vx[ii]; clip2_float_vy[ii] = debug_clip_float_vy[ii]; }
            } else {
                if (clip2_float_vx) { free(clip2_float_vx); clip2_float_vx = NULL; }
                if (clip2_float_vy) { free(clip2_float_vy); clip2_float_vy = NULL; }
                clip2_float_vcount = 0;
            }
        }

        printf("  segi=%d cont12=%d cont21=%d sample_ok=%d ia1=%.6f ia2=%.6f\n", segi, cont12, cont21, sample_ok, ia1, ia2);

        /* Write diagnostics to centroid files for copy-out from GS */
        FILE *cf = fopen("centroid.txt","w");
        if (cf) {
            fprintf(cf, "pair,%d,%d,ov,%d\n", f1, f2, ov);
            fprintf(cf, "segi,%d,cont12,%d,cont21,%d,sample_ok,%d\n", segi, cont12, cont21, sample_ok);
            fprintf(cf, "face1,%d,verts:\n", f1);
            for (int k = 0; k < n1; ++k) fprintf(cf, "%d,%d\n", xs1[k], ys1[k]);
            fprintf(cf, "face2,%d,verts:\n", f2);
            for (int k = 0; k < n2; ++k) fprintf(cf, "%d,%d\n", xs2[k], ys2[k]);
            fprintf(cf, "samples (tx,ty,in1,in2):\n");
            for (int s = 0; s < samp_count; ++s) fprintf(cf, "%d,%d,%d,%d\n", samp_pts[s][0], samp_pts[s][1], samp_pts[s][2], samp_pts[s][3]);
            fprintf(cf, "clip1_centroid,%d,%d,area,%.6f\n", icx1, icy1, ia1);
            /* write clipped verts captured during compute (if any) */
            if (clip1_vcount > 0) {
                fprintf(cf, "clip1_verts_count,%d\n", clip1_vcount);
                fprintf(cf, "clip1_verts:");
                for (int k = 0; k < clip1_vcount; ++k) fprintf(cf, ",%d:%d", clip1_vx[k], clip1_vy[k]);
                fprintf(cf, "\n");
                fprintf(cf, "clip1_debug_area,%.6f,clip1_raw_area2,%lld,clip1_debug_centroid,%d,%d,clip1_float_area,%.6f,clip1_float_overridden,%d\n", clip1_area, clip1_raw_area2, clip1_centx, clip1_centy, clip1_float_area, clip1_float_overridden);
                if (clip1_float_vcount > 0) {
                    fprintf(cf, "clip1_float_verts_count,%d\n", clip1_float_vcount);
                    fprintf(cf, "clip1_float_verts:");
                    for (int k = 0; k < clip1_float_vcount; ++k) fprintf(cf, ",%d:%d", clip1_float_vx[k], clip1_float_vy[k]);
                    fprintf(cf, "\n");
                }
            } else {
                fprintf(cf, "clip1_verts_count,0\n");
            }
            fprintf(cf, "clip2_centroid,%d,%d,area,%.6f\n", icx2, icy2, ia2);
            if (clip2_vcount > 0) {
                fprintf(cf, "clip2_verts_count,%d\n", clip2_vcount);
                fprintf(cf, "clip2_verts:");
                for (int k = 0; k < clip2_vcount; ++k) fprintf(cf, ",%d:%d", clip2_vx[k], clip2_vy[k]);
                fprintf(cf, "\n");
                fprintf(cf, "clip2_debug_area,%.6f,clip2_raw_area2,%lld,clip2_debug_centroid,%d,%d,clip2_float_area,%.6f,clip2_float_overridden,%d\n", clip2_area, clip2_raw_area2, clip2_centx, clip2_centy, clip2_float_area, clip2_float_overridden);
                if (clip2_float_vcount > 0) {
                    fprintf(cf, "clip2_float_verts_count,%d\n", clip2_float_vcount);
                    fprintf(cf, "clip2_float_verts:");
                    for (int k = 0; k < clip2_float_vcount; ++k) fprintf(cf, ",%d:%d", clip2_float_vx[k], clip2_float_vy[k]);
                    fprintf(cf, "\n");
                }
            } else {
                fprintf(cf, "clip2_verts_count,0\n");
            }
            /* also write projection scale and bbox area */
            if (clip1_vx) { free(clip1_vx); clip1_vx = NULL; }
            if (clip1_vy) { free(clip1_vy); clip1_vy = NULL; }
            if (clip2_vx) { free(clip2_vx); clip2_vx = NULL; }
            if (clip2_vy) { free(clip2_vy); clip2_vy = NULL; }
            if (clip1_float_vx) { free(clip1_float_vx); clip1_float_vx = NULL; }
            if (clip1_float_vy) { free(clip1_float_vy); clip1_float_vy = NULL; }
            if (clip2_float_vx) { free(clip2_float_vx); clip2_float_vx = NULL; }
            if (clip2_float_vy) { free(clip2_float_vy); clip2_float_vy = NULL; }

            int bx0 = faces->minx[f1] > faces->minx[f2] ? faces->minx[f1] : faces->minx[f2];
            int bx1 = faces->maxx[f1] < faces->maxx[f2] ? faces->maxx[f1] : faces->maxx[f2];
            int by0 = faces->miny[f1] > faces->miny[f2] ? faces->miny[f1] : faces->miny[f2];
            int by1 = faces->maxy[f1] < faces->maxy[f2] ? faces->maxy[f1] : faces->maxy[f2];
            double bbox_area = 0.0; if (bx0 <= bx1 && by0 <= by1) bbox_area = (double)(bx1 - bx0) * (double)(by1 - by0);
            fprintf(cf, "proj_scale,%.6f,screenScale,%d,bbox_area,%.6f\n", FIXED_TO_FLOAT(s_global_proj_scale_fixed), mode/320, bbox_area);
            fclose(cf);

            /* free temporary clip arrays (no longer needed) */
            if (clip1_vx) { free(clip1_vx); clip1_vx = NULL; }
            if (clip1_vy) { free(clip1_vy); clip1_vy = NULL; }
            if (clip2_vx) { free(clip2_vx); clip2_vx = NULL; }
            if (clip2_vy) { free(clip2_vy); clip2_vy = NULL; }

            /* Scale sweep diagnostics: reprojection at multiple zoom multipliers to detect scale-dependent flips */
            if (dbg_pair_i) {
                FILE *cfs = fopen("centroid.txt","a");
                if (cfs) {
                    Fixed32 saved_scale = s_global_proj_scale_fixed;
                    int mults[] = {1, 2, 4, 8};
                    fprintf(cfs, "scale_sweep,cur_scale,%.4f\n", FIXED_TO_FLOAT(saved_scale));
                    for (int mi = 0; mi < (int)(sizeof(mults)/sizeof(mults[0])); ++mi) {
                        int m = mults[mi];
                        Fixed32 new_scale = FIXED_MUL_64(saved_scale, INT_TO_FIXED(m));
                        s_global_proj_scale_fixed = new_scale;
                        /* recompute 2D projection under new scale */
                        compute2DFromObserver(model, params->angle_w);
                        int ov_s = projected_polygons_overlap(model, f1, f2);
                        int ocx1 = 0, ocy1 = 0, ocx2 = 0, ocy2 = 0; double oia1 = 0.0, oia2 = 0.0;
                        overlapClipCalls++;
                        compute_intersection_centroid_ordered(model, f1, f2, &ocx1, &ocy1, &oia1);
                        compute_intersection_centroid_ordered(model, f2, f1, &ocx2, &ocy2, &oia2);
                        double obest = oia1;
                        if (oia2 > obest) obest = oia2;
                        if (obest >= MIN_INTERSECTION_AREA_PIXELS) overlapClipAccept++;
                        fprintf(cfs, "mult,%d,scale,%.4f,ov,%d,ia1,%.6f,ia2,%.6f,ic1,%d,%d,ic2,%d,%d\n",
                                m, FIXED_TO_FLOAT(new_scale), ov_s, oia1, oia2, ocx1, ocy1, ocx2, ocy2);
                    }
                    fclose(cfs);
                    /* restore projection */
                    s_global_proj_scale_fixed = saved_scale;
                    compute2DFromObserver(model, params->angle_w);
                }
            }
        }
    }

    // Ask user whether to show faces on model (default = YES on empty input)
    char resp[16];
    printf("Show faces on model? (O/n) [ENTER = yes]: ");
    if (fgets(resp, sizeof(resp), stdin) == NULL) return;
    if (resp[0] == 'N' || resp[0] == 'n') return; // explicit no
    // anything else (including '\n' on empty line) -> show

    // Prepare view and display f1 (green) and f2 (orange)
    startgraph(mode);
    unsigned char* backup_flags = (unsigned char*)malloc(faces->face_count);
    for (int i = 0; i < faces->face_count; ++i) backup_flags[i] = faces->display_flag[i];

    int old_frame = framePolyOnly;
    framePolyOnly = 1; // not filled

    // Show the entire model in wireframe first, then overlay the two faces
    for (int i = 0; i < faces->face_count; ++i) faces->display_flag[i] = 1; // ensure all faces visible for wireframe
    if (jitter) drawPolygons_jitter(model, faces->vertex_count, faces->face_count, model->vertices.vertex_count); else drawPolygons(model, faces->vertex_count, faces->face_count, model->vertices.vertex_count);

    // Overlay explicit colored faces (ensure visibility); force the two faces visible and draw indices
    unsigned char saved_f1 = faces->display_flag[f1]; unsigned char saved_f2 = faces->display_flag[f2];
    faces->display_flag[f1] = 1;
    faces->display_flag[f2] = 1;
    drawFace(model, f1, 10, 1); // green with index
    drawFace(model, f2, 6, 1);  // orange with index
    // restore (though we restore all flags later from backup)
    faces->display_flag[f1] = saved_f1; faces->display_flag[f2] = saved_f2;

    MoveTo(3, 185);
    printf("%d and %d overlap: %s\n", f1, f2, ov ? "YES" : "NO");
    printf("'F' to save overlap.csv, any key to return\n");

    /* Read hardware key directly (same technique used in main loop) */
    int inspector_key = 0;
    asm {
        sep #0x20
    readloop2:
        lda >0xC000
        bpl readloop2
        and #0x007f
        sta inspector_key
        sta >0xC010
        rep #0x30
    }

    if (inspector_key == 'F' || inspector_key == 'f') {
        FILE *of = fopen("overlap.csv", "w");
        if (of) {
            fprintf(of, "face1,%d,face2,%d,overlap,%s\n", f1, f2, ov ? "YES" : "NO");
            fprintf(of, "face_id,vertex_order,vertex_index,x2d,y2d\n");
            int off1 = faces->vertex_indices_ptr[f1];
            int n1 = faces->vertex_count[f1];
            for (int vi = 0; vi < n1; ++vi) {
                int idx = faces->vertex_indices_buffer[off1 + vi] - 1;
                if (idx >= 0 && idx < vtx->vertex_count) fprintf(of, "%d,%d,%d,%d,%d\n", f1, vi, idx, vtx->x2d[idx], vtx->y2d[idx]);
            }
            int off2 = faces->vertex_indices_ptr[f2];
            int n2 = faces->vertex_count[f2];
            for (int vi = 0; vi < n2; ++vi) {
                int idx = faces->vertex_indices_buffer[off2 + vi] - 1;
                if (idx >= 0 && idx < vtx->vertex_count) fprintf(of, "%d,%d,%d,%d,%d\n", f2, vi, idx, vtx->x2d[idx], vtx->y2d[idx]);
            }
            fclose(of);
            printf("Saved overlap.csv\n");
        } else {
            printf("Error: cannot open overlap.csv for writing\n");
        }
    }

    endgraph();
    DoText();

    // Restore state
    framePolyOnly = old_frame;
    for (int i = 0; i < faces->face_count; ++i) faces->display_flag[i] = backup_flags[i];
    free(backup_flags);
}
********************* fin inspect_polygons_overlap avec debug *********************

********************* SAV segs_intersect_int *********************
static int segs_intersect_int(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4) {
    long long o1 = orient_ll(x1,y1,x2,y2,x3,y3);
    long long o2 = orient_ll(x1,y1,x2,y2,x4,y4);
    long long o3 = orient_ll(x3,y3,x4,y4,x1,y1);
    long long o4 = orient_ll(x3,y3,x4,y4,x2,y2);
    /* Proper intersection only: require strict orientation differences
     * This excludes colinear overlaps and endpoint-touching, which we treat
     * as NON-overlapping for the purposes of projected_polygons_overlap. */
    if (((o1 > 0 && o2 < 0) || (o1 < 0 && o2 > 0)) && ((o3 > 0 && o4 < 0) || (o3 < 0 && o4 > 0))) return 1;
    /* Ignore colinear or on-segment cases (return 0) */
    return 0;
}

********************* SAV scan_all_overlaps *********************
/* Global non-interactive scanner (triggered by G/g) that writes ovscan.csv and ovscanrpt.txt */
void scan_all_overlaps(Model3D* model, ObserverParams* params) {
    if (!model) { printf("No model loaded\n"); return; }
    FaceArrays3D* faces = &model->faces; VertexArrays3D* vtx = &model->vertices;

    int saved_jitter = jitter; jitter = 0;
    Fixed32 saved_scale = s_global_proj_scale_fixed;

    /* gather bbox-intersecting pairs */
    typedef struct { int a; int b; } Pair;
    int pair_count = 0;
    for (int i = 0; i < faces->face_count; ++i) for (int j = i+1; j < faces->face_count; ++j) {
        if (cull_back_faces) { if (faces->plane_d[i] <= 0 || faces->plane_d[j] <= 0) continue; }
        int minx1 = faces->minx[i], maxx1 = faces->maxx[i], miny1 = faces->miny[i], maxy1 = faces->maxy[i];
        int minx2 = faces->minx[j], maxx2 = faces->maxx[j], miny2 = faces->miny[j], maxy2 = faces->maxy[j];
        if (maxx1 <= minx2 || maxx2 <= minx1 || maxy1 <= miny2 || maxy2 <= miny1) continue;
        pair_count++;
    }
    if (pair_count == 0) { printf("No bbox-intersecting pairs found.\n"); jitter = saved_jitter; return; }
    Pair* pairs = (Pair*)malloc(sizeof(Pair) * pair_count); int pi = 0;
    for (int i = 0; i < faces->face_count; ++i) for (int j = i+1; j < faces->face_count; ++j) {
        if (cull_back_faces) { if (faces->plane_d[i] <= 0 || faces->plane_d[j] <= 0) continue; }
        int minx1 = faces->minx[i], maxx1 = faces->maxx[i], miny1 = faces->miny[i], maxy1 = faces->maxy[i];
        int minx2 = faces->minx[j], maxx2 = faces->maxx[j], miny2 = faces->miny[j], maxy2 = faces->maxy[j];
        if (maxx1 <= minx2 || maxx2 <= minx1 || maxy1 <= miny2 || maxy2 <= miny1) continue;
        pairs[pi].a = i; pairs[pi].b = j; pi++;
    }

    FILE *of = fopen("ovscan.csv","w");
    if (!of) { printf("Error: cannot open ovscan.csv for writing\n"); free(pairs); jitter = saved_jitter; return; }
    fprintf(of, "f1,f2,ov_current,ov_fixed,ov_float,ia1_fixed,ia2_fixed,ia1_float,ia2_float,bbox_area,cf1_fixed_v,cf1_float_v,cf2_fixed_v,cf2_float_v,cf1_raw_area2,cf2_raw_area2,cf1_float_over,cf2_float_over,notes\n");

    int divergent_pairs = 0; int override_changed = 0;
    for (int k = 0; k < pair_count; ++k) {
        int f1 = pairs[k].a; int f2 = pairs[k].b;
        compute2DFromObserver(model, params->angle_w);
        int ov_current = projected_polygons_overlap(model, f1, f2);

        int icx1=0,icy1=0; double ia1=0.0; debug_overlap_subj = f1; debug_overlap_clip = f2; compute_intersection_centroid_ordered(model, f1, f2, &icx1, &icy1, &ia1); debug_overlap_subj = -1; debug_overlap_clip = -1;
        double ia1_fixed = debug_clip_fixed_area; double ia1_float = debug_clip_float_area; int cf1_fixed_v = debug_clip_fixed_vcount; int cf1_float_v = debug_clip_float_vcount; long long cf1_raw = debug_clip_raw_area2; int cf1_float_over = debug_clip_float_overridden;

        int icx2=0,icy2=0; double ia2=0.0; debug_overlap_subj = f2; debug_overlap_clip = f1; compute_intersection_centroid_ordered(model, f2, f1, &icx2, &icy2, &ia2); debug_overlap_subj = -1; debug_overlap_clip = -1;
        double ia2_fixed = debug_clip_fixed_area; double ia2_float = debug_clip_float_area; int cf2_fixed_v = debug_clip_fixed_vcount; int cf2_float_v = debug_clip_float_vcount; long long cf2_raw = debug_clip_raw_area2; int cf2_float_over = debug_clip_float_overridden;

        int bx0 = faces->minx[f1] > faces->minx[f2] ? faces->minx[f1] : faces->minx[f2];
        int bx1 = faces->maxx[f1] < faces->maxx[f2] ? faces->maxx[f1] : faces->maxx[f2];
        int by0 = faces->miny[f1] > faces->miny[f2] ? faces->miny[f1] : faces->miny[f2];
        int by1 = faces->maxy[f1] < faces->maxy[f2] ? faces->maxy[f1] : faces->maxy[f2];
        double bbox_area = 0.0; if (bx0 <= bx1 && by0 <= by1) bbox_area = (double)(bx1 - bx0) * (double)(by1 - by0);
        const double eps = 1e-9;
        int valid1_fixed = (cf1_fixed_v >= 3 && ia1_fixed >= MIN_INTERSECTION_AREA_PIXELS && ia1_fixed <= bbox_area + eps);
        int valid2_fixed = (cf2_fixed_v >= 3 && ia2_fixed >= MIN_INTERSECTION_AREA_PIXELS && ia2_fixed <= bbox_area + eps);
        int ov_fixed = (valid1_fixed || valid2_fixed) ? 1 : 0;
        int valid1_float = (cf1_float_v >= 3 && ia1_float >= MIN_INTERSECTION_AREA_PIXELS && ia1_float <= bbox_area + eps);
        int valid2_float = (cf2_float_v >= 3 && ia2_float >= MIN_INTERSECTION_AREA_PIXELS && ia2_float <= bbox_area + eps);
        int ov_float = (valid1_float || valid2_float) ? 1 : 0;
        char notes[128] = "";
        if (ov_fixed != ov_float) { divergent_pairs++; snprintf(notes, sizeof(notes), "ov_fixed!=ov_float"); }
        if (ov_current != ov_fixed) { override_changed++; if (notes[0]) strncat(notes, ";cur!=fixed", sizeof(notes)-strlen(notes)-1); else snprintf(notes, sizeof(notes), "cur!=fixed"); }
        fprintf(of, "%d,%d,%d,%d,%d,%.6f,%.6f,%.6f,%.6f,%.6f,%d,%d,%d,%d,%lld,%lld,%d,%d,%s\n",
                f1, f2, ov_current, ov_fixed, ov_float, ia1_fixed, ia2_fixed, ia1_float, ia2_float, bbox_area,
                cf1_fixed_v, cf1_float_v, cf2_fixed_v, cf2_float_v, cf1_raw, cf2_raw, cf1_float_over, cf2_float_over, notes);
    }
    fclose(of);
    FILE *rf = fopen("ovscanrpt.txt","w");
    if (rf) { fprintf(rf, "ovscan: total_pairs,%d,divergent_pairs,%d,override_changed,%d\n", pair_count, divergent_pairs, override_changed); fclose(rf); }
    printf("Scan complete: %d pairs scanned, %d divergent, %d where current differs from fixed\n", pair_count, divergent_pairs, override_changed);
    free(pairs);
    jitter = saved_jitter; s_global_proj_scale_fixed = saved_scale;
}
********************* fin SAV scan_all_overlaps *********************
