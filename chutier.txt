/* OLD CODE from GS3Dp.cc */


/* Archived: fitModelToView (removed from GS3Dp.cc)
 * void fitModelToView(Model3D* model, ObserverParams* params, float target_max_dim, float margin, float percentile, int center_flag)
 *
 * Archived here per request. This copy preserves the behavior that computes a centroid
 * and stores it in the model struct without modifying vertex coordinates or params->distance.
 */
void fitModelToView(Model3D* model, ObserverParams* params, float target_max_dim, float margin, float percentile, int center_flag) {
    if (model == NULL || params == NULL) return;
    VertexArrays3D* vtx = &model->vertices;
    int n = vtx->vertex_count; if (n <= 0) return;

    double cx = 0.0, cy = 0.0, cz = 0.0; int count = 0;
    for (int i = 0; i < n; ++i) {
        Fixed32 xi = model->orig_x ? model->orig_x[i] : vtx->x[i];
        Fixed32 yi = model->orig_y ? model->orig_y[i] : vtx->y[i];
        Fixed32 zi = model->orig_z ? model->orig_z[i] : vtx->z[i];
        cx += FIXED_TO_FLOAT(xi); cy += FIXED_TO_FLOAT(yi); cz += FIXED_TO_FLOAT(zi);
        count++;
    }
    if (count > 0) {
        cx /= (double)count; cy /= (double)count; cz /= (double)count;
        model->auto_center_x = FLOAT_TO_FIXED((float)cx);
        model->auto_center_y = FLOAT_TO_FIXED((float)cy);
        model->auto_center_z = FLOAT_TO_FIXED((float)cz);
        model->auto_centered = 0; // original implementation did not mark coords as modified
    }
}




/**
 * painter_newell_sanchaV2 -- Variant using optimized bubble sort
 * --------------------------------------------------------------
 * Behavior:
 *  - Semantically identical to `painter_newell_sancha()` but uses an optimized
 *    bubble-sort style outer loop (decreasing upper bound + early exit on sorted)
 *    as requested (see pseudo-code in the change request).
 *  - The pairwise comparison performed for deciding swaps is the same sequence of
 *    tests (1..7) used by the original algorithm (depth, bbox X/Y, plane tests).
 *
 * Rationale:
 *  - This variant attempts to minimize the number of pair tests by reducing the
 *    inner loop range as larger elements bubble toward the end of the array; it
 *    also exits early if no swaps occur in a pass.
 */
void painter_newell_sanchaV2(Model3D* model, int face_count) {
    if (use_float_painter) { painter_newell_sancha_float(model, face_count); return; }
    FaceArrays3D* faces = &model->faces;
    VertexArrays3D* vtx = &model->vertices;
    int i, j;
    Fixed32* face_zmean = faces->z_mean;
    if (!face_zmean) return; // safety

    // Step 1: initial ordering by z_mean (descending stable sort on visible subset)
    int visible_count = face_count;
    if (cull_back_faces) {
        visible_count = 0;
        for (i = 0; i < face_count; ++i) {
            if (faces->display_flag[i]) faces->sorted_face_indices[visible_count++] = i;
        }
        int tail = visible_count;
        for (i = 0; i < face_count; ++i) {
            if (!faces->display_flag[i]) faces->sorted_face_indices[tail++] = i;
        }
    } else {
        for (i = 0; i < face_count; ++i) faces->sorted_face_indices[i] = i;
    }
    qsort_faces_ptr_for_cmp = faces;
    qsort(faces->sorted_face_indices, visible_count, sizeof(int), cmp_faces_by_zmean);
    qsort_faces_ptr_for_cmp = NULL;

    // Prepare caches and diagnostic buffers (same strategy as V1)
    typedef struct { int face1; int face2; } OrderedPair;
    int ordered_pairs_capacity = face_count * 4;
    OrderedPair* ordered_pairs = NULL;
    if (ordered_pairs_capacity > 0) {
        ordered_pairs = (OrderedPair*)malloc(ordered_pairs_capacity * sizeof(OrderedPair));
        if (!ordered_pairs) ordered_pairs_capacity = 0;
    }
    int ordered_pairs_count = 0;

    if (inconclusive_pairs) { free(inconclusive_pairs); inconclusive_pairs = NULL; }
    inconclusive_pairs_capacity = face_count * 4;
    if (inconclusive_pairs_capacity > 0) {
        inconclusive_pairs = (InconclusivePair*)malloc(inconclusive_pairs_capacity * sizeof(InconclusivePair));
        if (!inconclusive_pairs) inconclusive_pairs_capacity = 0;
    }
    inconclusive_pairs_count = 0;

    // Optimized bubble-like passes: outer bound decreases each pass, early exit when sorted
    int swap_count = 0;
    for (int pass = visible_count - 1; pass >= 1; --pass) {
        int tableau_trie = 1; // true: no swaps so far in this pass
        for (j = 0; j <= pass - 1; ++j) {
            int f1 = faces->sorted_face_indices[j];
            int f2 = faces->sorted_face_indices[j+1];

            // Skip pairs already declared ordered
            int already_ordered = 0;
            for (int p = 0; p < ordered_pairs_count; ++p) {
                if ((ordered_pairs[p].face1 == f1 && ordered_pairs[p].face2 == f2) ||
                    (ordered_pairs[p].face1 == f2 && ordered_pairs[p].face2 == f1)) { already_ordered = 1; break; }
            }
            if (already_ordered) continue;

            // --- Test 1: Depth overlap (cheap) ---
            if (faces->z_max[f2] <= faces->z_min[f1]) continue;
            if (faces->z_max[f1] <= faces->z_min[f2]) {
                // definite swap
                int tmp = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = faces->sorted_face_indices[j+1]; faces->sorted_face_indices[j+1] = tmp;
                tableau_trie = 0; swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }

            // --- Test 2: X bbox separation ---
            int minx1 = faces->minx[f1], maxx1 = faces->maxx[f1], miny1 = faces->miny[f1], maxy1 = faces->maxy[f1];
            int minx2 = faces->minx[f2], maxx2 = faces->maxx[f2], miny2 = faces->miny[f2], maxy2 = faces->maxy[f2];
            if (maxx1 <= minx2 || maxx2 <= minx1) continue;

            // --- Test 3: Y bbox separation ---
            if (maxy1 <= miny2 || maxy2 <= miny1) continue;

            // --- Tests 4..7: plane-based robust checks (copied from painter_newell_sancha) ---
            int n1 = faces->vertex_count[f1];
            int n2 = faces->vertex_count[f2];
            int offset1 = faces->vertex_indices_ptr[f1];
            int offset2 = faces->vertex_indices_ptr[f2];
            int k;
            Fixed64 a1 = faces->plane_a[f1]; Fixed64 b1 = faces->plane_b[f1]; Fixed64 c1 = faces->plane_c[f1]; Fixed64 d1 = faces->plane_d[f1];
            Fixed64 a2 = faces->plane_a[f2]; Fixed64 b2 = faces->plane_b[f2]; Fixed64 c2 = faces->plane_c[f2]; Fixed64 d2 = faces->plane_d[f2];
            Fixed32 epsilon = FLOAT_TO_FIXED(0.01f);

            int obs_side1 = 0; int obs_side2 = 0; int side; int all_same_side; int all_opposite_side;

            // Test 4
            obs_side1 = 0; if (d1 > (Fixed64)epsilon) obs_side1 = 1; else if (d1 < -(Fixed64)epsilon) obs_side1 = -1; else goto skipT4V2;
            all_same_side = 1;
            for (k=0; k<n2; k++) {
                int v = faces->vertex_indices_buffer[offset2+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a1 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b1 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c1 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d1;
                if  (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side1 != side) { all_same_side = 0; break; }
            }
            if (all_same_side) continue;
            skipT4V2: ;

            // Test 5
            obs_side2 = 0; if (d2 > (Fixed64)epsilon) obs_side2 = 1; else if (d2 < -(Fixed64)epsilon) obs_side2 = -1; else goto skipT5V2;
            all_opposite_side = 1;
            for (k=0; k<n1; k++) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a2 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b2 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c2 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d2;
                if  (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side2 == side) { all_opposite_side = 0; break; }
            }
            if (all_opposite_side) continue;
            skipT5V2: ;

            // Test 6
            obs_side1 = 0; if (d1 > (Fixed64)epsilon) obs_side1 = 1; else if (d1 < -(Fixed64)epsilon) obs_side1 = -1; else goto skipT6V2;
            all_opposite_side = 1;
            for (k=0; k<n2; k++) {
                int v = faces->vertex_indices_buffer[offset2+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a1 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b1 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c1 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d1;
                if  (acc > (Fixed64)epsilon) side = 1; else if  (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side1 == side) { all_opposite_side = 0; break; }
            }
            if (all_opposite_side) {
                // swap
                int tmp = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = faces->sorted_face_indices[j+1]; faces->sorted_face_indices[j+1] = tmp;
                tableau_trie = 0; swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }
            skipT6V2: ;

            // Test 7
            obs_side2 = 0; if (d2 > (Fixed64)epsilon) obs_side2 = 1; else if (d2 < -(Fixed64)epsilon) obs_side2 = -1; else goto skipT7V2;
            all_same_side = 1;
            for (k=0; k<n1; k++) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a2 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b2 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c2 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d2;
                if  (acc > (Fixed64)epsilon) side = 1; else if  (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side2 != side) { all_same_side = 0; break; }
            }
            if (all_same_side) {
                int tmp = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = faces->sorted_face_indices[j+1]; faces->sorted_face_indices[j+1] = tmp;
                tableau_trie = 0; swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }
            skipT7V2: ;

            // Non-conclusive: record and avoid re-testing
            if (inconclusive_pairs != NULL && inconclusive_pairs_count < inconclusive_pairs_capacity) {
                inconclusive_pairs[inconclusive_pairs_count].face1 = f1; inconclusive_pairs[inconclusive_pairs_count].face2 = f2; inconclusive_pairs_count++;
            }
            if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }

        } // end inner for j
        if (tableau_trie) break; // early exit, already sorted
    } // end passes
    printf("inconclusive pairs: %d, total swaps: %d\n", inconclusive_pairs_count, swap_count);
    keypress();

    if (ordered_pairs) free(ordered_pairs);
}



/**
 * painter_newell_sanchaV3 -- Variant using all-pairs double loop
 * ---------------------------------------------------------------
 * Behavior:
 *  - Same semantics as `painter_newell_sancha()` but the correction phase is performed
 *    by comparing each face to *all* subsequent faces using a nested double loop
 *    (for i=0..N-2, for j=i+1..N-1). This implements a full pairwise pass instead
 *    of adjacent-only bubble swaps.
 *
 * Rationale & tradeoffs:
 *  - This approach can be more thorough (it directly compares distant elements),
 *    but it does more pair tests (O(N^2) comparisons) and may be slower on large
 *    models unless pruned by early rejection tests (depth/bbox) — the same tests
 *    1..7 are used as in V1 for conclusive decisions.
 *  - The function preserves diagnostic behavior: ordered_pairs and inconclusive_pairs
 *    are used to avoid re-testing and to record ambiguous pairs.
 */
void painter_newell_sanchaV3(Model3D* model, int face_count) {
    if (use_float_painter) { painter_newell_sancha_float(model, face_count); return; }
    FaceArrays3D* faces = &model->faces;
    VertexArrays3D* vtx = &model->vertices;
    int i, j;
    Fixed32* face_zmean = faces->z_mean;
    if (!face_zmean) return; // safety

    // Initial ordering by z_mean (same as V1/V2)
    int visible_count = face_count;
    if (cull_back_faces) {
        visible_count = 0;
        for (i = 0; i < face_count; ++i) if (faces->display_flag[i]) faces->sorted_face_indices[visible_count++] = i;
        int tail = visible_count;
        for (i = 0; i < face_count; ++i) if (!faces->display_flag[i]) faces->sorted_face_indices[tail++] = i;
    } else {
        for (i = 0; i < face_count; ++i) faces->sorted_face_indices[i] = i;
    }
    qsort_faces_ptr_for_cmp = faces;
    qsort(faces->sorted_face_indices, visible_count, sizeof(int), cmp_faces_by_zmean);
    qsort_faces_ptr_for_cmp = NULL;

    // Prepare ordered_pairs cache and inconclusive buffer (same strategy as V1)
    typedef struct { int face1; int face2; } OrderedPair;
    int ordered_pairs_capacity = face_count * 4;
    OrderedPair* ordered_pairs = NULL;
    if (ordered_pairs_capacity > 0) {
        ordered_pairs = (OrderedPair*)malloc(ordered_pairs_capacity * sizeof(OrderedPair));
        if (!ordered_pairs) ordered_pairs_capacity = 0;
    }
    int ordered_pairs_count = 0;

    if (inconclusive_pairs) { free(inconclusive_pairs); inconclusive_pairs = NULL; }
    inconclusive_pairs_capacity = face_count * 4;
    if (inconclusive_pairs_capacity > 0) {
        inconclusive_pairs = (InconclusivePair*)malloc(inconclusive_pairs_capacity * sizeof(InconclusivePair));
        if (!inconclusive_pairs) inconclusive_pairs_capacity = 0;
    }
    inconclusive_pairs_count = 0;

    int swap_count = 0;

    // All-pairs comparison: for each face i compare to all faces j > i
    for (i = 0; i < visible_count - 1; ++i) {
        for (j = i + 1; j < visible_count; ++j) {
            int f1 = faces->sorted_face_indices[i];
            int f2 = faces->sorted_face_indices[j];

            // Skip if already known
            int already_ordered = 0;
            for (int p = 0; p < ordered_pairs_count; ++p) {
                if ((ordered_pairs[p].face1 == f1 && ordered_pairs[p].face2 == f2) ||
                    (ordered_pairs[p].face1 == f2 && ordered_pairs[p].face2 == f1)) { already_ordered = 1; break; }
            }
            if (already_ordered) continue;

            // Quick rejects / accepts (Tests 1..3)
            if (faces->z_max[f2] <= faces->z_min[f1]) continue; // f1 before f2, OK
            if (faces->z_max[f1] <= faces->z_min[f2]) {
                // definitive: f2 before f1 -> swap positions
                int tmp = faces->sorted_face_indices[i]; faces->sorted_face_indices[i] = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = tmp;
                swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }
            int minx1 = faces->minx[f1], maxx1 = faces->maxx[f1], miny1 = faces->miny[f1], maxy1 = faces->maxy[f1];
            int minx2 = faces->minx[f2], maxx2 = faces->maxx[f2], miny2 = faces->miny[f2], maxy2 = faces->maxy[f2];
            if (maxx1 <= minx2 || maxx2 <= minx1) continue;
            if (maxy1 <= miny2 || maxy2 <= miny1) continue;

            // Plane-based tests (4..7) copied from V1/V2
            int n1 = faces->vertex_count[f1];
            int n2 = faces->vertex_count[f2];
            int offset1 = faces->vertex_indices_ptr[f1];
            int offset2 = faces->vertex_indices_ptr[f2];
            int k;
            Fixed64 a1 = faces->plane_a[f1]; Fixed64 b1 = faces->plane_b[f1]; Fixed64 c1 = faces->plane_c[f1]; Fixed64 d1 = faces->plane_d[f1];
            Fixed64 a2 = faces->plane_a[f2]; Fixed64 b2 = faces->plane_b[f2]; Fixed64 c2 = faces->plane_c[f2]; Fixed64 d2 = faces->plane_d[f2];
            Fixed32 epsilon = FLOAT_TO_FIXED(0.01f);

            int obs_side1 = 0; int obs_side2 = 0; int side; int all_same_side; int all_opposite_side;

            // Test 4
            obs_side1 = 0; if (d1 > (Fixed64)epsilon) obs_side1 = 1; else if (d1 < -(Fixed64)epsilon) obs_side1 = -1; else goto skipT4V3;
            all_same_side = 1;
            for (k = 0; k < n2; ++k) {
                int v = faces->vertex_indices_buffer[offset2+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a1 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b1 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c1 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d1;
                if (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side1 != side) { all_same_side = 0; break; }
            }
            if (all_same_side) continue;
            skipT4V3: ;

            // Test 5
            obs_side2 = 0; if (d2 > (Fixed64)epsilon) obs_side2 = 1; else if (d2 < -(Fixed64)epsilon) obs_side2 = -1; else goto skipT5V3;
            all_opposite_side = 1;
            for (k = 0; k < n1; ++k) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a2 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b2 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c2 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d2;
                if (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side2 == side) { all_opposite_side = 0; break; }
            }
            if (all_opposite_side) continue;
            skipT5V3: ;

            // Test 6
            obs_side1 = 0; if (d1 > (Fixed64)epsilon) obs_side1 = 1; else if (d1 < -(Fixed64)epsilon) obs_side1 = -1; else goto skipT6V3;
            all_opposite_side = 1;
            for (k = 0; k < n2; ++k) {
                int v = faces->vertex_indices_buffer[offset2+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a1 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b1 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c1 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d1;
                if (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side1 == side) { all_opposite_side = 0; break; }
            }
            if (all_opposite_side) {
                // swap
                int tmp = faces->sorted_face_indices[i]; faces->sorted_face_indices[i] = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = tmp;
                swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }
            skipT6V3: ;

            // Test 7
            obs_side2 = 0; if (d2 > (Fixed64)epsilon) obs_side2 = 1; else if (d2 < -(Fixed64)epsilon) obs_side2 = -1; else goto skipT7V3;
            all_same_side = 1;
            for (k = 0; k < n1; ++k) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                Fixed64 acc = 0;
                acc  = (((Fixed64)a2 * (Fixed64)vtx->xo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)b2 * (Fixed64)vtx->yo[v]) >> FIXED_SHIFT);
                acc += (((Fixed64)c2 * (Fixed64)vtx->zo[v]) >> FIXED_SHIFT);
                acc += (Fixed64)d2;
                if (acc > (Fixed64)epsilon) side = 1; else if (acc < -(Fixed64)epsilon) side = -1; else continue;
                if (obs_side2 != side) { all_same_side = 0; break; }
            }
            if (all_same_side) {
                int tmp = faces->sorted_face_indices[i]; faces->sorted_face_indices[i] = faces->sorted_face_indices[j]; faces->sorted_face_indices[j] = tmp;
                swap_count++;
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }
                continue;
            }
            skipT7V3: ;

            // Non-conclusive: record and avoid re-testing
            if (inconclusive_pairs != NULL && inconclusive_pairs_count < inconclusive_pairs_capacity) { inconclusive_pairs[inconclusive_pairs_count].face1 = f1; inconclusive_pairs[inconclusive_pairs_count].face2 = f2; inconclusive_pairs_count++; }
            if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) { ordered_pairs[ordered_pairs_count].face1 = f2; ordered_pairs[ordered_pairs_count].face2 = f1; ordered_pairs_count++; }

        }
    }

    if (ordered_pairs) free(ordered_pairs);
}


        /* Smoke-test mode: run a small non-interactive test to validate auto-fit and key behavior */
        if (argc > 1 && strcmp(argv[1], "--smoke-test") == 0) {
            printf("Running smoke test...\n");
            /* Create a minimal OBJ file */
            const char* testfile = "smoke_test.obj";
            FILE* tf = fopen(testfile, "w");
            if (tf == NULL) {
                printf("Failed to create %s\n", testfile);
                return 1;
            }
            fputs("v 0 0 0\nv 1 0 0\nv 0 1 0\nf 1 2 3\n", tf);
            fclose(tf);

            int res = loadModel3D(model, testfile);
            if (res != 0) {
                printf("loadModel3D failed (%d)\n", res);
                return 1;
            }
            printf("auto_fit_ready=%d\n", model->auto_fit_ready);
            printf("auto_suggested_distance=%.4f\n", FIXED_TO_FLOAT(model->auto_suggested_distance));
            printf("auto_suggested_proj_scale=%.2f\n", FIXED_TO_FLOAT(model->auto_suggested_proj_scale));

            /* Simulate the '+' handler */
            Fixed32 cur = s_global_proj_scale_fixed;
            Fixed32 mulp = FLOAT_TO_FIXED(1.1f);
            Fixed32 plus_scale = FIXED_MUL_64(cur, mulp);
            printf("scale_before=%.2f scale_after_plus=%.2f\n", FIXED_TO_FLOAT(cur), FIXED_TO_FLOAT(plus_scale));

            /* Simulate the '-' handler */
            Fixed32 mulm = FLOAT_TO_FIXED(0.9f);
            Fixed32 minus_scale = FIXED_MUL_64(cur, mulm);
            printf("scale_after_minus=%.2f\n", FIXED_TO_FLOAT(minus_scale));

            /* Simulate A/Z on distance */
            Fixed32 dcur = model->auto_suggested_distance;
            Fixed32 d_a = dcur - (dcur / 10); // A (decrease by 10%)
            Fixed32 d_z = dcur + (dcur / 10); // Z (increase by 10%)
            printf("distance_before=%.4f distance_A=%.4f distance_Z=%.4f\n", FIXED_TO_FLOAT(dcur), FIXED_TO_FLOAT(d_a), FIXED_TO_FLOAT(d_z));

            printf("Smoke test completed.\n");
            return 0;
        }


        
// Lightweight wireframe processing: only transform & project vertices, set face visibility
// No per-face depth calculations or sorting performed here for maximum speed in wireframe mode
segment "code11";
void processModelWireframe(Model3D* model, ObserverParams* params, const char* filename) {
    int i, j;
    Fixed32 cos_h, sin_h, cos_v, sin_v, cos_w, sin_w;
    Fixed32 x, y, z, zo, xo, yo;
    Fixed32 inv_zo, x2d_temp, y2d_temp;

    cos_h = cos_deg_int(params->angle_h);
    sin_h = sin_deg_int(params->angle_h);
    cos_v = cos_deg_int(params->angle_v);
    sin_v = sin_deg_int(params->angle_v);
    cos_w = cos_deg_int(params->angle_w);
    sin_w = sin_deg_int(params->angle_w);

    const Fixed32 cos_h_cos_v = FIXED_MUL_64(cos_h, cos_v);
    const Fixed32 sin_h_cos_v = FIXED_MUL_64(sin_h, cos_v);
    const Fixed32 cos_h_sin_v = FIXED_MUL_64(cos_h, sin_v);
    const Fixed32 sin_h_sin_v = FIXED_MUL_64(sin_h, sin_v);
    Fixed32 scale = s_global_proj_scale_fixed;
    const Fixed32 centre_x_f = INT_TO_FIXED(CENTRE_X);
    const Fixed32 centre_y_f = INT_TO_FIXED(CENTRE_Y);
    const Fixed32 distance = params->distance;

    VertexArrays3D* vtx = &model->vertices;
    Fixed32 *x_arr = vtx->x, *y_arr = vtx->y, *z_arr = vtx->z;
    Fixed32 *xo_arr = vtx->xo, *yo_arr = vtx->yo, *zo_arr = vtx->zo;
    int *x2d_arr = vtx->x2d, *y2d_arr = vtx->y2d;
    int vcount = vtx->vertex_count;

    // Local copies for speed
    FaceArrays3D* faces = &model->faces;
    int *vertex_indices_buffer = faces->vertex_indices_buffer;
    int *vertex_indices_ptr = faces->vertex_indices_ptr;
    int *face_vertex_count = faces->vertex_count;

    for (i = 0; i < vcount; i++) {
        x = x_arr[i];
        y = y_arr[i];
        z = z_arr[i];
        Fixed32 term1 = FIXED_MUL_64(x, cos_h_cos_v);
        Fixed32 term2 = FIXED_MUL_64(y, sin_h_cos_v);
        Fixed32 term3 = FIXED_MUL_64(z, sin_v);
        zo = FIXED_ADD(FIXED_SUB(FIXED_SUB(FIXED_NEG(term1), term2), term3), distance);
        if (zo > 0) {
            // compute projected xy directly into x2d/y2d and store intermediate observer coords for depth tests
            Fixed32 xo_local = FIXED_ADD(FIXED_NEG(FIXED_MUL_64(x, sin_h)), FIXED_MUL_64(y, cos_h));
            Fixed32 yo_local = FIXED_ADD(FIXED_SUB(FIXED_NEG(FIXED_MUL_64(x, cos_h_sin_v)), FIXED_MUL_64(y, sin_h_sin_v)), FIXED_MUL_64(z, cos_v));
            inv_zo = FIXED_DIV_64(scale, zo);
            Fixed32 tmp_x = FIXED_ADD(FIXED_MUL_64(xo_local, inv_zo), centre_x_f);
            Fixed32 tmp_y = FIXED_SUB(centre_y_f, FIXED_MUL_64(yo_local, inv_zo));
            // apply screen rotation and round
            x2d_arr[i] = FIXED_ROUND_TO_INT(FIXED_ADD(FIXED_SUB(FIXED_MUL_64(cos_w, FIXED_SUB(tmp_x, centre_x_f)), FIXED_MUL_64(sin_w, FIXED_SUB(centre_y_f, tmp_y))), centre_x_f));
            y2d_arr[i] = FIXED_ROUND_TO_INT(FIXED_SUB(centre_y_f, FIXED_ADD(FIXED_MUL_64(sin_w, FIXED_SUB(tmp_x, centre_x_f)), FIXED_MUL_64(cos_w, FIXED_SUB(centre_y_f, tmp_y)))));
            // Store observer-space coordinates so subsequent face tests see valid values
            zo_arr[i] = zo;
            xo_arr[i] = xo_local;
            yo_arr[i] = yo_local;
        } else {
            // negative zo (behind camera) — mark as invalid projection and store zo<=0
            zo_arr[i] = zo;
            xo_arr[i] = 0;
            yo_arr[i] = 0;
            x2d_arr[i] = -1;
            y2d_arr[i] = -1;
        }
    }

    // Set simple visibility flag per face: visible if any vertex projected on-screen (x2d != -1)
    for (i = 0; i < faces->face_count; ++i) {
        int offset = vertex_indices_ptr[i];
        int vcount_face = face_vertex_count[i];
        int *indices_base = &vertex_indices_buffer[offset];
        int visible = 0;
        for (j = 0; j < vcount_face; ++j) {
            int vi = indices_base[j] - 1;
            if (vi >= 0 && vi < vcount && x2d_arr[vi] != -1) { visible = 1; break; }
        }
        faces->display_flag[i] = visible;
        faces->sorted_face_indices[i] = i; // identity order; no sorting required
    }
}

/* ===== ARCHIVE (moved from DONYGS.cc) =====
 * Function: move_element_remove_and_insert
 * Moved: 2026-01-11
 * Reason: replaced by optimized variant `move_element_remove_and_insert_pos` and
 *         wrapper left in place for compatibility. Original implementation
 *         archived here for reference.
 */
static int move_element_remove_and_insert(int *arr, int n, int from, int insert_idx) {
    if (from < 0 || from >= n) return 0;
    if (insert_idx < 0) insert_idx = 0;
    if (insert_idx > n-1) insert_idx = n-1;
    if (from == insert_idx) return 0;
    int val = arr[from];
    if (insert_idx < from) {
        /* shift left region [insert_idx..from-1] right by 1 */
        memmove(&arr[insert_idx+1], &arr[insert_idx], (from - insert_idx) * sizeof(int));
        arr[insert_idx] = val;
    } else {
        /* insert_idx > from: shift region [from+1..insert_idx] left by 1 */
        memmove(&arr[from], &arr[from+1], (insert_idx - from) * sizeof(int));
        arr[insert_idx] = val;
    }
    return 1;
}

/* End of archive block */



/* DEBUG bloc dans ray_cast
    // ============================================
    // DEBUG COMPLET - Écriture dans cast.txt
    // ============================================

    FILE* debug_file = fopen("cast.txt", "a");  // "a" pour append (ajouter à la fin)
    if (debug_file == NULL) {
        printf("ERREUR: Impossible d'ouvrir cast.txt\n");
        return 0;
    }

    fprintf(debug_file, "\n");
    fprintf(debug_file, "================================================================\n");
    fprintf(debug_file, "                  RAY_CAST DEBUG COMPLET                        \n");
    fprintf(debug_file, "================================================================\n");

    // 1. Info sur les faces comparées
    fprintf(debug_file, "\n[1] FACES COMPAREES:\n");
    fprintf(debug_file, "    Face f1 = %d\n", f1);
    fprintf(debug_file, "    Face f2 = %d\n", f2);

    // 2. Bounding boxes et intersection
    fprintf(debug_file, "\n[2] BOUNDING BOXES 2D:\n");
    fprintf(debug_file, "    f1: [%d,%d] -> [%d,%d]\n", minx1, miny1, maxx1, maxy1);
    fprintf(debug_file, "    f2: [%d,%d] -> [%d,%d]\n", minx2, miny2, maxx2, maxy2);
    fprintf(debug_file, "    Intersection: [%d,%d] -> [%d,%d]\n", ix0, iy0, ix1, iy1);
    fprintf(debug_file, "    Centre teste: (%d, %d)\n", cx, cy);

    // 3. Direction du rayon
    fprintf(debug_file, "\n[3] RAYON 3D:\n");
    fprintf(debug_file, "    Origine: (0, 0, 0)\n");
    fprintf(debug_file, "    Direction: (%.6f, %.6f, %.6f)\n", Dx, Dy, Dz);
    float ray_length = sqrtf(Dx*Dx + Dy*Dy + Dz*Dz);
    fprintf(debug_file, "    Longueur: %.6f %s\n", ray_length, 
        (fabsf(ray_length - 1.0f) < 0.01f) ? "(normalise)" : "(NON normalise)");

    // 4. Équations des plans
    fprintf(debug_file, "\n[4] EQUATIONS DES PLANS:\n");
    fprintf(debug_file, "    f1: %.2f*x + %.2f*y + %.2f*z + %.2f = 0\n", A1, B1, C1, D1);
    fprintf(debug_file, "    f2: %.2f*x + %.2f*y + %.2f*z + %.2f = 0\n", A2, B2, C2, D2);

    // Normaliser les normales pour voir leur direction
    float len1 = sqrtf(A1*A1 + B1*B1 + C1*C1);
    float len2 = sqrtf(A2*A2 + B2*B2 + C2*C2);
    fprintf(debug_file, "    Normale f1: (%.3f, %.3f, %.3f) [longueur=%.2f]\n", 
        A1/len1, B1/len1, C1/len1, len1);
    fprintf(debug_file, "    Normale f2: (%.3f, %.3f, %.3f) [longueur=%.2f]\n", 
        A2/len2, B2/len2, C2/len2, len2);

    // 5. Produits scalaires (denominateurs)
    fprintf(debug_file, "\n[5] PRODUITS SCALAIRES (normale . rayon):\n");
    fprintf(debug_file, "    denom1 = %.6f %s\n", denom1, 
        (denom1 < 0) ? "(face frontale)" : "(face arriere)");
    fprintf(debug_file, "    denom2 = %.6f %s\n", denom2, 
        (denom2 < 0) ? "(face frontale)" : "(face arriere)");

    // 6. Distances calculées
    fprintf(debug_file, "\n[6] DISTANCES (parametre t):\n");
    fprintf(debug_file, "    tf1 = -D1/denom1 = -(%.2f)/(%.2f) = %.6f\n", D1, denom1, tf1);
    fprintf(debug_file, "    tf2 = -D2/denom2 = -(%.2f)/(%.2f) = %.6f\n", D2, denom2, tf2);
    fprintf(debug_file, "    |tf1| = %.6f\n", fabsf(tf1));
    fprintf(debug_file, "    |tf2| = %.6f\n", fabsf(tf2));
    fprintf(debug_file, "    Difference: |tf1 - tf2| = %.6f\n", fabsf(tf1 - tf2));

    // 7. Points d'intersection 3D
    fprintf(debug_file, "\n[7] POINTS D'INTERSECTION 3D:\n");
    float x1 = Dx * tf1;
    float y1 = Dy * tf1;
    float z1 = Dz * tf1;
    float x2 = Dx * tf2;
    float y2 = Dy * tf2;
    float z2 = Dz * tf2;
    fprintf(debug_file, "    f1: (%.2f, %.2f, %.2f) -> Z = %.2f\n", x1, y1, z1, z1);
    fprintf(debug_file, "    f2: (%.2f, %.2f, %.2f) -> Z = %.2f\n", x2, y2, z2, z2);

    // Vérification: le point est-il bien sur le plan ?
    float verif1 = A1*x1 + B1*y1 + C1*z1 + D1;
    float verif2 = A2*x2 + B2*y2 + C2*z2 + D2;
    fprintf(debug_file, "    Verification f1 (devrait etre 0): %.6f %s\n", verif1,
        (fabsf(verif1) < 1.0f) ? "OK" : "ERREUR");
    fprintf(debug_file, "    Verification f2 (devrait etre 0): %.6f %s\n", verif2,
        (fabsf(verif2) < 1.0f) ? "OK" : "ERREUR");

    // 8. Z des sommets réels des faces
    fprintf(debug_file, "\n[8] Z DES SOMMETS (coordonnees 3D transformees):\n");

    // Face f1
    int off1 = faces->vertex_indices_ptr[f1];
    int n1 = faces->vertex_count[f1];
    float z_min1 = 999999.0f, z_max1 = -999999.0f, z_sum1 = 0.0f;
    fprintf(debug_file, "    f1 sommets (%d): ", n1);
    for (int k = 0; k < n1; ++k) {
        int vi = faces->vertex_indices_buffer[off1 + k] - 1;
        if (vi >= 0 && vi < vtx->vertex_count) {
            // Use observer-space Z (vtx->zo) and convert from fixed to float for human-readable debug
            float z = FIXED_TO_FLOAT(vtx->zo[vi]);
            fprintf(debug_file, "%.3f ", z);
            if (z < z_min1) z_min1 = z;
            if (z > z_max1) z_max1 = z;
            z_sum1 += z;
        }
    }
    float z_avg1 = z_sum1 / (float)n1;
    fprintf(debug_file, "\n    f1: Z_min=%.2f, Z_max=%.2f, Z_avg=%.2f\n", z_min1, z_max1, z_avg1);

    // Face f2
    int off2 = faces->vertex_indices_ptr[f2];
    int n2 = faces->vertex_count[f2];
    float z_min2 = 999999.0f, z_max2 = -999999.0f, z_sum2 = 0.0f;
    fprintf(debug_file, "    f2 sommets (%d): ", n2);
    for (int k = 0; k < n2; ++k) {
        int vi = faces->vertex_indices_buffer[off2 + k] - 1;
        if (vi >= 0 && vi < vtx->vertex_count) {
            // Use observer-space Z (vtx->zo) and convert from fixed to float for human-readable debug
            float z = FIXED_TO_FLOAT(vtx->zo[vi]);
            fprintf(debug_file, "%.3f ", z);
            if (z < z_min2) z_min2 = z;
            if (z > z_max2) z_max2 = z;
            z_sum2 += z;
        }
    }
    float z_avg2 = z_sum2 / (float)n2;
    fprintf(debug_file, "\n    f2: Z_min=%.2f, Z_max=%.2f, Z_avg=%.2f\n", z_min2, z_max2, z_avg2);

    // 9. Comparaison des Z
    fprintf(debug_file, "\n[9] ANALYSE DES Z:\n");
    fprintf(debug_file, "    Comparaison des Z moyens: ");
    if (z_avg1 < z_avg2) {
        fprintf(debug_file, "f1 plus proche (%.2f < %.2f)\n", z_avg1, z_avg2);
    } else {
        fprintf(debug_file, "f2 plus proche (%.2f < %.2f)\n", z_avg2, z_avg1);
    }

    fprintf(debug_file, "    Comparaison des Z d'intersection: ");
    if (z1 < z2) {
        fprintf(debug_file, "f1 plus proche (%.2f < %.2f)\n", z1, z2);
    } else {
        fprintf(debug_file, "f2 plus proche (%.2f < %.2f)\n", z2, z1);
    }

    fprintf(debug_file, "    Comparaison des tf: ");
    if (tf1 < tf2) {
        fprintf(debug_file, "f1 plus proche (%.2f < %.2f)\n", tf1, tf2);
    } else {
        fprintf(debug_file, "f2 plus proche (%.2f < %.2f)\n", tf2, tf1);
    }

    // 10. Résultat final
    int result;
    if (tf1 > tf2) result = 1;
    else if (tf1 < tf2) result = -1;
    else result = 0;

    fprintf(debug_file, "\n[10] RESULTAT:\n");
    fprintf(debug_file, "    Code retourne: %d\n", result);
    if (result == -1) {
        fprintf(debug_file, "    -> f1 (face %d) est PLUS PROCHE que f2 (face %d)\n", f1, f2);
    } else if (result == 1) {
        fprintf(debug_file, "    -> f2 (face %d) est PLUS PROCHE que f1 (face %d)\n", f2, f1);
    } else {
        fprintf(debug_file, "    -> Faces a egale distance (ou coplanaires)\n");
    }

    fprintf(debug_file, "\n");
    fprintf(debug_file, "================================================================\n");
    fprintf(debug_file, "                      FIN DU DEBUG                              \n");
    fprintf(debug_file, "================================================================\n");
    fprintf(debug_file, "\n\n");

    fclose(debug_file);

    // ============================================
    // FIN DU DEBUG
    // ============================================
*/



/* Compute centroid of intersection polygon between faces f1 and f2 in screen space.
 * Uses Sutherland-Hodgman polygon clipping (f1 subject, f2 clip polygon) with strict
 * inside test (points on edges are treated as outside) so touching-only cases yield
 * zero-area result. Returns 1 and sets *outx,*outy when intersection has positive
 * area; returns 0 otherwise.
 */
static int compute_intersection_centroid(Model3D* model, int f1, int f2, int* outx, int* outy, double* out_area) {
    FaceArrays3D* faces = &model->faces;
    VertexArrays3D* vtx = &model->vertices;
    int n1 = faces->vertex_count[f1];
    int n2 = faces->vertex_count[f2];
    if (n1 <= 0 || n2 <= 0) { if (out_area) *out_area = 0.0; return 0; }

    /* Build subject polygon (from f1) as doubles */
    double* sx = (double*)malloc(sizeof(double) * n1);
    double* sy = (double*)malloc(sizeof(double) * n1);
    if (!sx || !sy) { if (sx) free(sx); if (sy) free(sy); if (out_area) *out_area = 0.0; return 0; }
    int off1 = faces->vertex_indices_ptr[f1];
    for (int i = 0; i < n1; ++i) {
        int vid = faces->vertex_indices_buffer[off1 + i] - 1;
        sx[i] = (double)vtx->x2d[vid];
        sy[i] = (double)vtx->y2d[vid];
    }
    int curr_n = n1;

    /* Temporary arrays for clipping --- allocate worst-case (n1 + n2) * 2 maybe */
    double* tx = (double*)malloc(sizeof(double) * (n1 + n2 + 8));
    double* ty = (double*)malloc(sizeof(double) * (n1 + n2 + 8));
    if (!tx || !ty) { free(sx); free(sy); if (tx) free(tx); if (ty) free(ty); if (out_area) *out_area = 0.0; return 0; }

    const double EPS = 1e-9;

    int off2 = faces->vertex_indices_ptr[f2];
    for (int j = 0; j < n2; ++j) {
        int c1 = faces->vertex_indices_buffer[off2 + j] - 1;
        int c2 = faces->vertex_indices_buffer[off2 + ((j + 1) % n2)] - 1;
        double cx1 = (double)vtx->x2d[c1], cy1 = (double)vtx->y2d[c1];
        double cx2 = (double)vtx->x2d[c2], cy2 = (double)vtx->y2d[c2];

        if (curr_n == 0) break;
        int out_n = 0;

        for (int i = 0; i < curr_n; ++i) {
            int ii = i;
            int jj = (i + 1) % curr_n;
            double sx1 = sx[ii], sy1 = sy[ii];
            double sx2 = sx[jj], sy2 = sy[jj];

            /* inside test: point is strictly to the left of clip edge (cx1->cx2) */
            double cross1 = (cx2 - cx1) * (sy1 - cy1) - (cy2 - cy1) * (sx1 - cx1);
            double cross2 = (cx2 - cx1) * (sy2 - cy1) - (cy2 - cy1) * (sx2 - cx1);
            int in1 = (cross1 > EPS);
            int in2 = (cross2 > EPS);

            if (in1 && in2) {
                /* both inside -> keep end */
                tx[out_n] = sx2; ty[out_n] = sy2; out_n++;
            } else if (in1 && !in2) {
                /* leaving: emit intersection */
                double denom = (sx1 - sx2) * (cy1 - cy2) - (sy1 - sy2) * (cx1 - cx2);
                if (fabs(denom) > 1e-12) {
                    double numx = (sx1*sy2 - sy1*sx2) * (cx1 - cx2) - (sx1 - sx2) * (cx1*cy2 - cy1*cx2);
                    double numy = (sx1*sy2 - sy1*sx2) * (cy1 - cy2) - (sy1 - sy2) * (cx1*cy2 - cy1*cx2);
                    double ix = numx / denom;
                    double iy = numy / denom;
                    tx[out_n] = ix; ty[out_n] = iy; out_n++;
                }
            } else if (!in1 && in2) {
                /* entering: emit intersection then end point */
                double denom = (sx1 - sx2) * (cy1 - cy2) - (sy1 - sy2) * (cx1 - cx2);
                if (fabs(denom) > 1e-12) {
                    double numx = (sx1*sy2 - sy1*sx2) * (cx1 - cx2) - (sx1 - sx2) * (cx1*cy2 - cy1*cx2);
                    double numy = (sx1*sy2 - sy1*sx2) * (cy1 - cy2) - (sy1 - sy2) * (cx1*cy2 - cy1*cx2);
                    double ix = numx / denom;
                    double iy = numy / denom;
                    tx[out_n] = ix; ty[out_n] = iy; out_n++;
                }
                tx[out_n] = sx2; ty[out_n] = sy2; out_n++;
            } else {
                /* both outside -> nothing */
            }
        }

        /* swap tx->sx */
        if (out_n == 0) { curr_n = 0; break; }
        /* ensure capacity */
        for (int k = 0; k < out_n; ++k) { sx[k] = tx[k]; sy[k] = ty[k]; }
        curr_n = out_n;
    }

    int result = 0;
    double final_area = 0.0;
    if (curr_n >= 3) {
        /* compute signed area and centroid */
        double area2 = 0.0; /* 2*area */
        double cx = 0.0, cy = 0.0;
        for (int i = 0; i < curr_n; ++i) {
            int j = (i + 1) % curr_n;
            double a = sx[i] * sy[j] - sx[j] * sy[i];
            area2 += a;
            cx += (sx[i] + sx[j]) * a;
            cy += (sy[i] + sy[j]) * a;
        }
        double area = 0.5 * area2;
        final_area = area;
        if (fabs(area) > 1e-6) {
            cx = cx / (6.0 * area);
            cy = cy / (6.0 * area);
            *outx = (int) (cx >= 0.0 ? cx + 0.5 : cx - 0.5);
            *outy = (int) (cy >= 0.0 ? cy + 0.5 : cy - 0.5);
            result = 1;
        }
    }

    if (out_area) *out_area = final_area;
    free(sx); free(sy); free(tx); free(ty);
    return result;
}

void scan_all_overlap_noninteractive(Model3D* model, ObserverParams* params, const char* filename) {
    printf("scan_all_overlap_noninteractive removed; use interactive ',' then 'a' to scan\n"); return;

    ObserverParams local_params;
    if (!params) {
        local_params.angle_h = 30; local_params.angle_v = 20; local_params.angle_w = 0;
        local_params.distance = FLOAT_TO_FIXED(30.0);
        params = &local_params;
    }
    /* Ensure projections and preprocessing are up to date */
    processModelFast(model, params, filename);

    FaceArrays3D* faces = &model->faces;
    VertexArrays3D* vtx = &model->vertices;

    /* Build CSV buffer in memory (same logic as interactive scan) */
    const char *finalname = "overlapall.csv";
    remove(finalname);
    char *buf = NULL; size_t blen = 0, bcap = 0;
    char tmp[512]; int tn = 0;
    int matches = 0; int processed = 0;

    for (int i = 0; i < faces->face_count; ++i) {
        for (int j = i + 1; j < faces->face_count; ++j) {
            int minx1 = faces->minx[i], maxx1 = faces->maxx[i], miny1 = faces->miny[i], maxy1 = faces->maxy[i];
            int minx2 = faces->minx[j], maxx2 = faces->maxx[j], miny2 = faces->miny[j], maxy2 = faces->maxy[j];
            if (maxx1 <= minx2 || maxx2 <= minx1 || maxy1 <= miny2 || maxy2 <= miny1) { processed++; continue; }
            int ov = projected_polygons_overlap(model, i, j);
            tn = snprintf(tmp, sizeof(tmp), "face1,%d,face2,%d,overlap,%s\n", i, j, ov ? "YES" : "NO");
            if (tn < 0) { if (buf) free(buf); printf("Error forming CSV\n"); return; }
            if (blen + tn + 1 > bcap) {
                size_t need = blen + tn + 1; size_t newcap = bcap ? bcap * 2 : need + 1024; while (newcap < need) newcap *= 2; char *nb = (char*)realloc(buf, newcap); if (!nb) { if (buf) free(buf); printf("Memory alloc error\n"); return; } buf = nb; bcap = newcap;
            }
            memcpy(buf + blen, tmp, tn); blen += tn; buf[blen] = '\0';

            if ((tn = snprintf(tmp, sizeof(tmp), "face_id,vertex_order,vertex_index,x2d,y2d\n")) < 0) { if (buf) free(buf); printf("Error forming CSV\n"); return; }
            if (blen + tn + 1 > bcap) { size_t need = blen + tn + 1; size_t newcap = bcap ? bcap * 2 : need + 1024; while (newcap < need) newcap *= 2; char *nb = (char*)realloc(buf, newcap); if (!nb) { if (buf) free(buf); printf("Memory alloc error\n"); return; } buf = nb; bcap = newcap; }
            memcpy(buf + blen, tmp, tn); blen += tn; buf[blen] = '\0';

            int off1 = faces->vertex_indices_ptr[i]; int n1 = faces->vertex_count[i];
            for (int vi = 0; vi < n1; ++vi) {
                int idxv = faces->vertex_indices_buffer[off1 + vi] - 1;
                if (idxv >= 0 && idxv < vtx->vertex_count) {
                    tn = snprintf(tmp, sizeof(tmp), "%d,%d,%d,%d,%d\n", i, vi, idxv, vtx->x2d[idxv], vtx->y2d[idxv]);
                    if (tn < 0) { if (buf) free(buf); printf("Error forming CSV\n"); return; }
                    if (blen + tn + 1 > bcap) { size_t need = blen + tn + 1; size_t newcap = bcap ? bcap * 2 : need + 1024; while (newcap < need) newcap *= 2; char *nb = (char*)realloc(buf, newcap); if (!nb) { if (buf) free(buf); printf("Memory alloc error\n"); return; } buf = nb; bcap = newcap; }
                    memcpy(buf + blen, tmp, tn); blen += tn; buf[blen] = '\0';
                }
            }

            int off2 = faces->vertex_indices_ptr[j]; int n2 = faces->vertex_count[j];
            for (int vi = 0; vi < n2; ++vi) {
                int idxv = faces->vertex_indices_buffer[off2 + vi] - 1;
                if (idxv >= 0 && idxv < vtx->vertex_count) {
                    tn = snprintf(tmp, sizeof(tmp), "%d,%d,%d,%d,%d\n", j, vi, idxv, vtx->x2d[idxv], vtx->y2d[idxv]);
                    if (tn < 0) { if (buf) free(buf); printf("Error forming CSV\n"); return; }
                    if (blen + tn + 1 > bcap) { size_t need = blen + tn + 1; size_t newcap = bcap ? bcap * 2 : need + 1024; while (newcap < need) newcap *= 2; char *nb = (char*)realloc(buf, newcap); if (!nb) { if (buf) free(buf); printf("Memory alloc error\n"); return; } buf = nb; bcap = newcap; }
                    memcpy(buf + blen, tmp, tn); blen += tn; buf[blen] = '\0';
                }
            }

            if ((tn = snprintf(tmp, sizeof(tmp), "\n")) < 0) { if (buf) free(buf); printf("Error forming CSV\n"); return; }
            if (blen + tn + 1 > bcap) { size_t need = blen + tn + 1; size_t newcap = bcap ? bcap * 2 : need + 1024; while (newcap < need) newcap *= 2; char *nb = (char*)realloc(buf, newcap); if (!nb) { if (buf) free(buf); printf("Memory alloc error\n"); return; } buf = nb; bcap = newcap; }
            memcpy(buf + blen, tmp, tn); blen += tn; buf[blen] = '\0';

            matches++; processed++;
        }
    }

    /* write debug CSV */
    FILE *dbf = fopen("overlapdbg.csv","w");
    if (dbf) {
        fprintf(dbf, "face1,face2,reported,sampled,clipped_area,identical\n");
        for (int ii = 0; ii < faces->face_count; ++ii) {
            for (int jj = ii + 1; jj < faces->face_count; ++jj) {
                int minx1b = faces->minx[ii], maxx1b = faces->maxx[ii], miny1b = faces->miny[ii], maxy1b = faces->maxy[ii];
                int minx2b = faces->minx[jj], maxx2b = faces->maxx[jj], miny2b = faces->miny[jj], maxy2b = faces->maxy[jj];
                if (maxx1b <= minx2b || maxx2b <= minx1b || maxy1b <= miny2b || maxy2b <= miny1b) continue;
                int ov2 = projected_polygons_overlap(model, ii, jj);
                int sampled2 = 0; int oxminb = minx1b > minx2b ? minx1b : minx2b; int oxmaxb = maxx1b < maxx2b ? maxx1b : maxx2b; int oyminb = miny1b > miny2b ? miny1b : miny2b; int oymaxb = maxy1b < maxy2b ? maxy1b : miny2b;
                if (!(oxminb > oxmaxb || oyminb > oymaxb)) {
                    int Wb = oxmaxb - oxminb; int Hb = oymaxb - oyminb;
                    for (int ssx = 0; ssx < 3 && !sampled2; ++ssx) for (int ssy = 0; ssy < 3 && !sampled2; ++ssy) {
                        int tx2 = oxminb + (((2*ssx + 1) * Wb + 3) / 6);
                        int ty2 = oyminb + (((2*ssy + 1) * Hb + 3) / 6);
                        if (point_in_poly_int(tx2, ty2, faces, vtx, ii, faces->vertex_count[ii]) && point_in_poly_int(tx2, ty2, faces, vtx, jj, faces->vertex_count[jj])) sampled2 = 1;
                    }
                }
                int icx2 = 0, icy2 = 0; double iarea2 = 0.0; compute_intersection_centroid(model, ii, jj, &icx2, &icy2, &iarea2);
                int ident2 = faces_vertices_equal(faces, vtx, ii, jj);
                fprintf(dbf, "%d,%d,%s,%d,%.6f,%d\n", ii, jj, ov2 ? "YES" : "NO", sampled2, iarea2, ident2);
            }
        }
        fclose(dbf);
    }

    /* Attempt single-shot write to final file to avoid partials on virtual disk */
    FILE *of = fopen(finalname, "w");
    if (!of) { if (buf) free(buf); printf("Error: cannot open %s for writing\n", finalname); return; }
    if (fwrite(buf ? buf : "", 1, blen, of) != blen) { printf("Write failed while saving %s\n", finalname); fclose(of); if (buf) free(buf); return; }
    fclose(of);
    if (buf) free(buf);
    printf("Saved overlapall.csv (%d pairs written, processed %d pairs)\n", matches, processed);
}




static void ensure_vertex_capacity(int vcount) {
    if (float_vcap >= vcount) return;
    int newcap = (vcount + 15) & ~15; // align
    float_xo = (float*)realloc(float_xo, sizeof(float) * newcap);
    float_yo = (float*)realloc(float_yo, sizeof(float) * newcap);
    float_zo = (float*)realloc(float_zo, sizeof(float) * newcap);
    float_px = (float*)realloc(float_px, sizeof(float) * newcap);
    float_py = (float*)realloc(float_py, sizeof(float) * newcap);
    float_px_int = (int*)realloc(float_px_int, sizeof(int) * newcap);
    float_py_int = (int*)realloc(float_py_int, sizeof(int) * newcap);
    float_vcap = newcap;
}
static void ensure_face_capacity(int face_count) {
    // allocate if not present
    if (f_z_min_buf && f_z_max_buf && f_z_mean_buf && f_minx_buf) { if (order_cap >= face_count) return; }
    int newcap = (face_count + 7) & ~7;
    int oldcap = order_cap;
    f_z_min_buf = (float*)realloc(f_z_min_buf, sizeof(float)*newcap);
    f_z_max_buf = (float*)realloc(f_z_max_buf, sizeof(float)*newcap);
    f_z_mean_buf = (float*)realloc(f_z_mean_buf, sizeof(float)*newcap);
    f_minx_buf = (int*)realloc(f_minx_buf, sizeof(int)*newcap);
    f_maxx_buf = (int*)realloc(f_maxx_buf, sizeof(int)*newcap);
    f_miny_buf = (int*)realloc(f_miny_buf, sizeof(int)*newcap);
    f_maxy_buf = (int*)realloc(f_maxy_buf, sizeof(int)*newcap);
    f_display_buf = (int*)realloc(f_display_buf, sizeof(int)*newcap);
    f_plane_a_buf = (float*)realloc(f_plane_a_buf, sizeof(float)*newcap);
    f_plane_b_buf = (float*)realloc(f_plane_b_buf, sizeof(float)*newcap);
    f_plane_c_buf = (float*)realloc(f_plane_c_buf, sizeof(float)*newcap);
    f_plane_d_buf = (float*)realloc(f_plane_d_buf, sizeof(float)*newcap);
    f_plane_conv_buf = (int*)realloc(f_plane_conv_buf, sizeof(int)*newcap);
    // initialize newly allocated region's conversion flags to 0
    if (f_plane_conv_buf && newcap > oldcap) memset(f_plane_conv_buf + oldcap, 0, sizeof(int)*(newcap - oldcap));
}

static void ensure_order_capacity(int face_count) {
    if (order_cap >= face_count) return;
    int newcap = (face_count + 7) & ~7;
    order_buf = (int*)realloc(order_buf, sizeof(int)*newcap);
    order_cap = newcap;
}

// Comparator support for qsort in painter_newell_sancha_float (float z_mean)
static float* qsort_fz_ptr_for_cmp = NULL;
static int cmp_faces_by_f_zmean(const void* pa, const void* pb) {
    int a = *(const int*)pa;
    int b = *(const int*)pb;
    float za = qsort_fz_ptr_for_cmp[a];
    float zb = qsort_fz_ptr_for_cmp[b];
    if (za > zb) return -1;   // larger z_mean first (descending)
    if (za < zb) return 1;
    if (a < b) return -1;     // tie-breaker: smaller index first
    if (a > b) return 1;
    return 0;
}

void painter_newell_sancha_float(Model3D* model, int face_count) {
    if (!model) return;
    VertexArrays3D* vtx = &model->vertices;
    FaceArrays3D* faces = &model->faces;
    int vcount = vtx->vertex_count;

    // Ensure reusable buffers are large enough and fill them
    ensure_vertex_capacity(vcount);
    ensure_face_capacity(face_count);
    ensure_order_capacity(face_count);


    typedef struct { int face1; int face2; } OrderedPair;
    int ordered_pairs_capacity = face_count * 4;
    OrderedPair* ordered_pairs = NULL;
    if (ordered_pairs_capacity > 0) {
        ordered_pairs = (OrderedPair*)malloc(ordered_pairs_capacity * sizeof(OrderedPair));
        if (!ordered_pairs) ordered_pairs_capacity = 0;
    }
    int ordered_pairs_count = 0;

    for (int i = 0; i < vcount; ++i) {
        float_xo[i] = FIXED_TO_FLOAT(vtx->xo[i]);
        float_yo[i] = FIXED_TO_FLOAT(vtx->yo[i]);
        float_zo[i] = FIXED_TO_FLOAT(vtx->zo[i]);
    }

    // Precompute projected px/py and integer screen coords per vertex (one division per vertex)
    float proj_scale = FIXED_TO_FLOAT(s_global_proj_scale_fixed);
    for (int i = 0; i < vcount; ++i) {
        float z = float_zo[i];
        float_px[i] = (z == 0.0f) ? float_xo[i] : (float_xo[i] / z);
        float_py[i] = (z == 0.0f) ? float_yo[i] : (float_yo[i] / z);
        float screenx = (0.0f - float_px[i]) * -proj_scale + (proj_scale * 0.5f);
        float screeny = (0.0f - float_py[i]) * -proj_scale + (proj_scale * 0.5f);
        float_px_int[i] = (int)(screenx + 0.5f);
        float_py_int[i] = (int)(screeny + 0.5f);
    }

    float *f_z_min = f_z_min_buf;
    float *f_z_max = f_z_max_buf;
    float *f_z_mean = f_z_mean_buf;
    int *f_minx = f_minx_buf;
    int *f_maxx = f_maxx_buf;
    int *f_miny = f_miny_buf;
    int *f_maxy = f_maxy_buf;
    int *f_display = f_display_buf;
    float *f_plane_a = f_plane_a_buf;
    float *f_plane_b = f_plane_b_buf;
    float *f_plane_c = f_plane_c_buf;
    float *f_plane_d = f_plane_d_buf;

    float proj_cx = 0.0f, proj_cy = 0.0f;
    for (int fi = 0; fi < face_count; ++fi) {
        int off = faces->vertex_indices_ptr[fi];
        int n = faces->vertex_count[fi];
        float zmin = 1e30f, zmaxf = -1e30f, sum = 0.0f;
        int minx = 999999, maxx = -999999, miny = 999999, maxy = -999999;
        int disp = 1;
        for (int k = 0; k < n; ++k) {
            int vid = faces->vertex_indices_buffer[off + k] - 1;
            if (vid < 0 || vid >= vcount) continue;
            float z = float_zo[vid]; if (z < 0.0f) disp = 0;
            if (z < zmin) zmin = z; if (z > zmaxf) zmaxf = z; sum += z;
            // use precomputed projected ints
            int sx = float_px_int[vid];
            int sy = float_py_int[vid];
            if (sx < minx) minx = sx; if (sx > maxx) maxx = sx; if (sy < miny) miny = sy; if (sy > maxy) maxy = sy;
        }
        if (!disp || n < 3) {
            f_plane_a[fi] = f_plane_b[fi] = f_plane_c[fi] = f_plane_d[fi] = 0.0f;
            f_plane_conv_buf[fi] = 1; // mark as converted (degenerate)
        }
        else {
            // Lazily convert Fixed32 plane coefficients to float only when needed.
            // Mark as not converted for now; conversion will happen in pair tests (T4/T5).
            f_plane_conv_buf[fi] = 0;
            f_plane_a[fi] = f_plane_b[fi] = f_plane_c[fi] = f_plane_d[fi] = 0.0f;
        }
        f_z_min[fi] = (n>0)?zmin:0.0f; f_z_max[fi] = (n>0)?zmaxf:0.0f; f_z_mean[fi] = (n>0)?(sum/n):0.0f;
        f_minx[fi] = (n>0)?minx:0; f_maxx[fi] = (n>0)?maxx:0; f_miny[fi] = (n>0)?miny:0; f_maxy[fi] = (n>0)?maxy:0; f_display[fi] = disp;
    }

    // initial order: reuse buffer
    int* order = order_buf;
    int visible_count = face_count;
    if (cull_back_faces) {
        visible_count = 0;
        for (int i = 0; i < face_count; ++i) {
            if (f_display[i]) order[visible_count++] = i;
        }
        // append culled faces to keep rest of array stable
        int tail = visible_count;
        for (int i = 0; i < face_count; ++i) {
            if (!f_display[i]) order[tail++] = i;
        }
    } else {
        for (int i = 0; i < face_count; ++i) order[i] = i;
    }

    // Sort faces by z_mean using qsort to match fixed-point painter (descending, tie-breaker: smaller index first)
    if (visible_count > 0) {
        qsort_fz_ptr_for_cmp = f_z_mean;
        qsort(order, visible_count, sizeof(int), cmp_faces_by_f_zmean);
        qsort_fz_ptr_for_cmp = NULL;
    }

    int swapped_local = 0;
    do {
        swapped_local = 0;
        for (int i = 0; i < visible_count - 1; ++i) {
            int f1 = order[i], f2 = order[i+1];
            /* linear check against ordered_pairs array */
            int already_ordered = 0;
            int p;
            for (p = 0; p < ordered_pairs_count; ++p) {
                if (ordered_pairs[p].face1 == f1 && ordered_pairs[p].face2 == f2) { already_ordered = 1; break; }
            }
            if (already_ordered) continue; 

            // Test 1 : Depth overlap (float)
            if (f_z_max[f2] <= f_z_min[f1]) continue;
            if (f_z_max[f1] <= f_z_min[f2]) {
                int tmp = order[i]; order[i] = order[i+1]; order[i+1] = tmp;
                swapped_local = 1;
                // record pair in ordered_pairs array (f2 before f1)
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) {
                    ordered_pairs[ordered_pairs_count].face1 = f2;
                    ordered_pairs[ordered_pairs_count].face2 = f1;
                    ordered_pairs_count++;
                }
                continue; 
            }

            // Test 2 : X overlap
            int minx1 = f_minx[f1], maxx1 = f_maxx[f1], miny1 = f_miny[f1], maxy1 = f_maxy[f1];
            int minx2 = f_minx[f2], maxx2 = f_maxx[f2], miny2 = f_miny[f2], maxy2 = f_maxy[f2];
            if (maxx1 <= minx2 || maxx2 <= minx1) continue;

            // Test 3 : Y overlap
            if (maxy1 <= miny2 || maxy2 <= miny1) continue;


            if (!projected_polygons_overlap(model, f1, f2)) continue;

            // Plane tests (4..7) using float plane coefficients
            int n1 = faces->vertex_count[f1];
            int n2 = faces->vertex_count[f2];
            int offset1 = faces->vertex_indices_ptr[f1];
            int offset2 = faces->vertex_indices_ptr[f2];
            float a1, b1, c1, d1;
            if (!f_plane_conv_buf[f1]) {
                a1 = (float)FIXED64_TO_FLOAT(faces->plane_a[f1]);
                b1 = (float)FIXED64_TO_FLOAT(faces->plane_b[f1]);
                c1 = (float)FIXED64_TO_FLOAT(faces->plane_c[f1]);
                d1 = (float)FIXED64_TO_FLOAT(faces->plane_d[f1]);
                f_plane_a[f1] = a1; f_plane_b[f1] = b1; f_plane_c[f1] = c1; f_plane_d[f1] = d1;
                f_plane_conv_buf[f1] = 1;
            } else { a1 = f_plane_a[f1]; b1 = f_plane_b[f1]; c1 = f_plane_c[f1]; d1 = f_plane_d[f1]; }

            float a2, b2, c2, d2;
            if (!f_plane_conv_buf[f2]) {
                a2 = (float)FIXED64_TO_FLOAT(faces->plane_a[f2]);
                b2 = (float)FIXED64_TO_FLOAT(faces->plane_b[f2]);
                c2 = (float)FIXED64_TO_FLOAT(faces->plane_c[f2]);
                d2 = (float)FIXED64_TO_FLOAT(faces->plane_d[f2]);
                f_plane_a[f2] = a2; f_plane_b[f2] = b2; f_plane_c[f2] = c2; f_plane_d[f2] = d2;
                f_plane_conv_buf[f2] = 1;
            } else { a2 = f_plane_a[f2]; b2 = f_plane_b[f2]; c2 = f_plane_c[f2]; d2 = f_plane_d[f2]; }

            /* Align epsilon with fixed-point painter */
            // float epsilon_f = 0.001f;
            float epsilon_f = 0.01f;

            // Test 4
            int obs_side1 = 0;
            int k;
            float test_val;
            if (d1 > epsilon_f) obs_side1 = 1; else if (d1 < -epsilon_f) obs_side1 = -1; else goto skipT4_float;
            int all_same_side = 1;
            for (k = 0; k < n2; ++k) {
                int v = faces->vertex_indices_buffer[offset2 + k] - 1;
                test_val = a1 * float_xo[v] + b1 * float_yo[v] + c1 * float_zo[v] + d1;  // plane of f1
                int side = (test_val > epsilon_f) ? 1 : ((test_val < -epsilon_f) ? -1 : 0);
                if (side != obs_side1) { all_same_side = 0; break; }
            }
            if (all_same_side) continue;
            skipT4_float: ;

            // Test 5
            int obs_side2 = 0; int all_opposite_side = 1;
            if (d2 > epsilon_f) obs_side2 = 1; else if (d2 < -epsilon_f) obs_side2 = -1; else goto skipT5_float;
            for (k = 0; k < n1; ++k) {
                int v = faces->vertex_indices_buffer[offset1 + k] - 1;
                test_val = a2 * float_xo[v] + b2 * float_yo[v] + c2 * float_zo[v] + d2; // plane of f2
                int side = (test_val > epsilon_f) ? 1 : ((test_val < -epsilon_f) ? -1 : 0);
                if (side == obs_side2) { all_opposite_side = 0; break; }
            }
            if (all_opposite_side) continue;
            
            skipT5_float: ;
        
            // Test 6 : Is f2 entirely on the opposite side of f1's plane relative to the observer?
            obs_side1 = 0;
            if (d1 > epsilon_f) obs_side1 = 1;
            else if (d1 < -epsilon_f) obs_side1 = -1;
            else goto skipT6_float;

            all_opposite_side = 1;
            for (k = 0; k < n2; ++k) {
                int v = faces->vertex_indices_buffer[offset2 + k] - 1;
                test_val = a1 * float_xo[v] + b1 * float_yo[v] + c1 * float_zo[v] + d1;
                int side = (test_val > epsilon_f) ? 1 : ((test_val < -epsilon_f) ? -1 : 0);
                if (side == 0) continue; /* ignore vertices exactly on the plane */
                if (obs_side1 == side) { 
                    all_opposite_side = 0; 
                    break; 
                }
            }
            if (all_opposite_side == 1) goto do_swap;

            skipT6_float: ;

            // Test 7 : Is f1 entirely on the same side of f2's plane as the observer?
            obs_side2 = 0;
            if (d2 > epsilon_f) obs_side2 = 1;
            else if (d2 < -epsilon_f) obs_side2 = -1;
            else goto skipT7_float;
            all_same_side = 1;
            for (k = 0; k < n1; ++k) {
                int v = faces->vertex_indices_buffer[offset1 + k] - 1;
                test_val = a2 * float_xo[v] + b2 * float_yo[v] + c2 * float_zo[v] + d2;
                int side = (test_val > epsilon_f) ? 1 : ((test_val < -epsilon_f) ? -1 : 0);
                if (side == 0) continue; /* ignore vertices exactly on the plane */
                if (obs_side2 != side) { 
                    all_same_side = 0; 
                    break; 
                }
            }
            if (all_same_side == 0) goto skipT7_float;
            else {
                goto do_swap;
            }

            // Si on arrive ici, les tests 1..5 n'ont pas conclu :
            // appliquer l'algorithme original de Newell/Newell/Sancha
            // => échanger les faces (swap) et enregistrer la paire
            do_swap:
            {
                int tmp = order[i]; order[i] = order[i+1]; order[i+1] = tmp;
                swapped_local = 1;
                // record pair in ordered_pairs array (f2 before f1)
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) {
                    ordered_pairs[ordered_pairs_count].face1 = f2;
                    ordered_pairs[ordered_pairs_count].face2 = f1;
                    ordered_pairs_count++;
                }
            }

            skipT7_float: ;

        } // end for
    } while (swapped_local);

    // write back order to faces->sorted_face_indices (visible faces first)
    int tail = 0;
    for (int i = 0; i < visible_count; ++i) faces->sorted_face_indices[tail++] = order[i];
    // append culled faces to fill rest (if culling active)
    if (cull_back_faces) {
        for (int i = 0; i < face_count; ++i) if (!f_display[i]) faces->sorted_face_indices[tail++] = i;
    } else {
        for (int i = visible_count; i < face_count; ++i) faces->sorted_face_indices[tail++] = order[i];
    }

    if (ordered_pairs) free(ordered_pairs);

    // Note: buffers are reused across invocations to avoid malloc/free overhead

}
