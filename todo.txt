
fixed:
probleme de overlap : 
avion, 90,20,0 (+ zoom) : o => 45 et 2 : overlap = NO : erreur !
avion, 110,20,0 (+ zoom) : o => 45 et 3 : overlap = YES : erreur !
Enregistrer dans un fichier les coordonnees des faces du modele ?


fixed:
probleme fil de fer : Ã  voir... solution provisoire : dans bigloop, faire un processModelFast(model, &params, filename);
Solution  ==> modification de processModelFast : if framePolyOnly : pas de tri des faces. Et bigloop quand framePolyOnly = 0.

TODO:
avec les angle 350 / 50, avion, les faces 3 et 44 sont en overlap, et sont inversÃ©es suivant le test after.

IA : 
ourquoi (briÃ¨vement) ğŸ’¡
Si tu compares A,B et B,C avec des tests dÃ©cisifs (â†’ A<B et B<C), puis A vs C est inconclusif et tu appliques Zmin pour trancher, tu peux obtenir C<A par Zmin.
RÃ©sultat : A<B, B<C, C<A â†’ cycle (nonâ€‘transitif).
Autrement dit, mÃ©langer des relations Â« dÃ©cidÃ©es Â» et des tieâ€‘breakers locaux ne garantit pas la transitivitÃ© du comparateur global.
Solution recommandÃ©e ğŸ”§
Construire dâ€™abord un graphe dirigÃ© Ã  partir des relations dÃ©cisives (arÃªtes f1â†’f2 quand test dit Â« f1 avant f2 Â»).
Tenter un tri topologique (Kahn) sur ce graphe :
si acyclique â†’ ordre compatible avec toutes relations dÃ©cisives ;
si cycle dÃ©tectÃ© â†’ rÃ©soudre le cycle en orientant/arbitrant les arÃªtes du cycle selon Zmin (ou une heuristique dÃ©terministe), puis relancer le topo.
Ceci garantit quâ€™on respecte prioritairement les relations dÃ©cidÃ©es et quâ€™on nâ€™introduit pas dâ€™ordre contradictoire arbitraire.
Proposition dâ€™implÃ©mentation
Jâ€™implÃ©mente le pipeline : construire graphe â†’ topo â†’ detection de cycles â†’ rÃ©solution par Zmin â†’ topo final, avec logs (mode debug).
Optionnel : un mode Â« agressif Â» qui applique ensuite swaps adjacents pour rapprocher/corriger lâ€™ordre effectif dans la structure existante.
Tu veux que je commence par lâ€™implÃ©mentation du tri


Alogo BRUNO : 
voilÃ  ce qu'on va faire : dans une nouvelle fonciton painter (painter_correct, par exemple), tu vas :

Pour chaque face, que j'appelle target :
1/ faire un test exactement comme inspect_before (sans les output Ã  l'Ã©cran). Si tu trouves 1 ou plusieurs faces mal placÃ©es ET qui overlap avec target,(qui devraient Ãªtre aprÃ¨s dans la liste), place target dans la liste AVANT le face trouvÃ©e aayant le plus petit indice.
2/ fait un test exactement comme inspect_after (sans les output Ã  l'Ã©cran). Si tu trouves 1 ou plusieurs faces mal placÃ©es ET qui overlap avec target, (qui devraient Ãªtre avant dans la liste), place target dans la liste APRES le face trouvÃ©e aayant le plus grand indice.
Fais le  
